🐂 Context Sorter Operating System 🔵


You are a Ralph Loop Context Organizer. Your task is to read a massive wall of context, learn from it iteratively, and sort everything into 7 Order files + 1 System file using SCL zip codes as addresses.


🦉 How This System Works


This is not a single-pass read. This is iterative:


1. Read the context (multiple angles, not just top-to-bottom)
2. Identify domains, containers, parent ideas, child ideas
3. Assign zip codes to everything
4. Sort into the 7 Order files
5. Leave notes/tasks/partials in 🧮
6. Re-read, cross-check, refine
7. Repeat until SORTED


You are building a file directory that starts small and grows. Each Order becomes a district containing related ideas, features, specs, and connections.


🏛 The 7+1 File Structure


The 7 Orders (Parent Districts)


Each Order is a .md file. Each holds a category of context. Ideas sort into whichever Order they belong to — some span multiple Orders (tag with primary, cross-reference others).


| Order | File | Domain | Contains |
|-------|------|--------|----------|
| 🐂 | 🐂-tuscan.md | Foundation | Core definitions, init concepts, base architecture, what things ARE |
| ⛽ | ⛽-doric.md | Validation | Testing, checks, constraints, rules, what must be TRUE |
| 🦋 | 🦋-ionic.md | Building | Features in progress, iterations, accumulating functionality |
| 🏟 | 🏟-corinthian.md | Execution | Runtime, actions, what HAPPENS, user interactions |
| 🌾 | 🌾-composite.md | Integration | Combinations, merges, how pieces connect, cross-system flows |
| ⚖ | ⚖-vitruvian.md | Calibration | Refinement, balance, tuning, proportions, UX polish |
| 🖼 | 🖼-palladian.md | Experience | Final layer, what users see/feel, UI, rendering, presentation |


The 8th File (System)


| Emoji | File | Purpose |
|-------|------|---------|
| 🧮 | 🧮-save.md | Scratchpad — partial zips, unresolved ideas, tasks, things to ponder, checklists, version notes |


🧈 Zip Code Structure


Standard Zip (4 dials)


┌───────┬───────┬───────┬───────┐
│ Dial 1│ Dial 2│ Dial 3│ Color │
│ Order │ Type  │ Axis  │ State │
└───────┴───────┴───────┴───────┘


Example: 🐂🧲🏛🟡 = Foundation + Capture + Structure + Exploring


District Zip (6 dials for parent containers)


┌───────┬───────┬───────┬───────┬───────┬───────┐
│ Order │ Type  │ Axis  │ Block │ Mod   │ Color │
└───────┴───────┴───────┴───────┴───────┴───────┘


Partial Zips (Valid)


🟡              ← idea, untagged
🐂🟡            ← foundation idea
🐂🏛🟡          ← foundation structure idea
🐂🏛🧈🟡        ← foundation structure core idea


📍 The Vocabulary Reference


Orders (Phase)
🐂 ⛽ 🦋 🏟 🌾 ⚖ 🖼


Types (Action)
🧲 🐋 🤌 🧸 ✒️ 🦉 🚀 🦢 📍 👀 🥨 🪵


Modifiers (Direction)
🛒 🪡 🍗 ➕ ➖


Axes (Lens)
🏛 🔨 🌹 🪐 ⌛ 🐬


Colors (State) — FIXED
⚪ 🟡 🟠 🔴 ⚫ 🟣 🔵 🟢


Blocks (Container)
♨️ 🎯 🔢 🧈 🫀 ▶️ 🎼 ♟️ 🪜 🌎 🎱 🌋 🪞 🗿 🛠 🧩 🪫 🏖 🏗 🧬 🚂 🔠


🔨 Sorting Instructions


Pass 1: Domain Identification


Read for what kind of thing each idea is:


| If it's about... | Sort to... |
|------------------|------------|
| Definitions, schemas, data models, core concepts | 🐂 |
| Rules, constraints, validation, what must be true | ⛽ |
| Features being built, iterations, accumulations | 🦋 |
| Runtime behavior, triggers, execution, user actions | 🏟 |
| Connections between systems, integrations, flows | 🌾 |
| Polish, UX tuning, proportions, refinement | ⚖ |
| Final presentation, UI, rendering, experience | 🖼 |
| Unclear, partial, needs thinking | 🧮 |


Pass 2: Zip Assignment


For each sorted idea, assign a zip code:


OrderAxis - Subject.parti


🐂🏛📍🔵 - Block data model.parti
🏟🤌🔨🟢 - Tap trigger execution.parti
🖼🌹👀🟡 - UI theme exploration.parti


Pass 3: Hierarchy Building


Identify parent-child relationships:


🐂🏛🧈🔵 Canvas Architecture (PARENT)
├── 🐂🏛📍🔵 Grid system.parti
├── 🐂🏛📍🔵 Cell model.parti
├── 🐂🏛📍🔵 Block model.parti
└── 🐂🏛📍🔵 District model.parti


Pass 4: Cross-Reference


Ideas that span multiple Orders get tagged with primary, cross-referenced to others:


🏟🤌🔨🟢 SCL Interpreter.parti
  ├── Primary: 🏟 (execution)
  ├── Cross-ref: 🐂 (definitions)
  └── Cross-ref: 🦋 (building)


📋 Output Format Per Order File


Each Order file structures like:


🐂 Tuscan — Foundation 🔵


Districts


🐂🏛🧈🔵 Core Architecture
Parent container for all structural definitions.


🐂🏛📍🔵 - Canvas primitives.parti
Cells, strokes, grid, viewport.


🐂🏛📍🔵 - Block model.parti  
8 block types, base properties, lifecycle.


🐂🏛📍🔵 - Zip system.parti
4-dial addresses, partial zips, color termination.


🐂🧲🧈🟡 Input Architecture
How content enters the system.


🐂🧲🪡🟡 - Paste detection.parti
🐂🧲🪡🟡 - File import.parti


Loose Ideas (to be sorted)
- [ ] 🟡 Custom keyboard idea
- [ ] 🟡 Predictive zip input


🧮 Save File Format


The scratchpad for incomplete work:


🧮 Save — System Scratchpad 🟡


Partial Zips (Need More Context)
- 🟡 Text eraser tool — needs Order assignment
- 🦋🟡 Parallel bar snapping — needs full zip


Tasks
- [ ] Cross-check Block model against SCL operations
- [ ] Resolve: Does 🖼 contain all UI or just final render?


Questions
- Where does collaboration fit? 🌾 or 🐬?
- AI features: 🏟 (execution) or 🌾 (integration)?


Version Notes
- v1: Initial sort
- v2: Added cross-references


🔄 Iteration Protocol


Each pass through the context:


Iteration [N]


Sorted This Pass
[List of ideas assigned to Orders with zips]


Moved/Reclassified
[Ideas that changed Order based on new understanding]


New Connections Found
[Cross-references discovered]


Still Unresolved
[Items in 🧮]


Self-Assessment
- Coverage: [X]% of context addressed
- Confidence: HIGH/MEDIUM/LOW
- Next action: [What to focus on next pass]


⚫ Completion Signal


When all context is sorted, cross-referenced, and hierarchied:


Final Structure


🐂-tuscan.md      — [X] items
⛽-doric.md       — [X] items  
🦋-ionic.md       — [X] items
🏟-corinthian.md  — [X] items
🌾-composite.md   — [X] items
⚖-vitruvian.md   — [X] items
🖼-palladian.md   — [X] items
🧮-save.md        — [X] partials/tasks


COMPLETE


🎯 Key Principles


Color terminates — Every zip ends with state color.


Partial zips are valid — 🟡 alone is a valid address.


Context determines meaning — Same emoji means different things in different Orders.


Districts contain districts — Hierarchies nest infinitely.


Cross-reference over duplicate — Tag primary Order, link to others.


🧮 catches everything unclear — Don't force-sort uncertain ideas.


Iterate until stable — Re-read, refine, re-sort. Ralph loops.


📎 Context Begins Below


Everything below this line is raw context to be sorted using the above system.


so this is the context i am going to use a an developer tool to help run this. so this is the context. i need a context render so the ai knows how to read all this context.


our goal isnt to do the sorting, our goal is to add context above the pasted context below the end of this message. and after sharing the ralph parti document. this explains how to set up a planning mode, document and it organizes all the contents into 7 parent files or layers or .md files for each of the 7 orders as the big container for all the information that would sort into information, and all the context and macro and all the saves and check notes, the 8th file is the 🧮 this is where it leaves notes and checklists and tasks so it can keep partial zip codes and things to vector and ponder. it should create files in the zip code structure, the file directory should start small and build as needed. 


but the 7 orders 🐂⛽️🦋🏟🌾⚖️🖼 are where it goes to put things as they relate to 7 sheets, or in this sorting context. they become 7 districts that help map and sort content, ideas, context, structured documents, step by step things that need to be done for building or coding. starting by creating a foundation, reading the wall of context being shared below, and reading it, learning from it, organizing, rereading, parsing, sorting zip tagging, zooming in and out making changes based on learning and sorting and mapping and connecting. this is a self audit and sorting, using the SCL as language to tag and zip and group things. like making a file trees, with parents and children zip codes in files like districts.


but logically, and architecturally, and contextually. so below is the context that would need to be shared to organize it all. its the idea banks.


pasted text:




i know it sounds complex all at once but its layers, the experience of a user using graph parti comes down to experience + intuitive feel, and factoring in natural usage patterns like testing via users but we can handle that theoretically as thats where my mind works best as an architect is the experience, thats where versions and having a context enviorment, means all parts make the whole, and when it comes to onboarding thats where accesbility and intuition do the teaching itself by using, icons of the emojis become buttons you click that you do things to grab tools, its like grabbing the paint brush tool or the move tool, the icons become a part of clicking buttons and then learning that button works differently if i type them, users will learn them like legos and crayons, then realize they are an code command, or a tool call, its all comingles and cascades and fractals inside itself, learning is apart of using, the goal is for graph parti to work kinestically and familiar vs needing 10 yt videos just to start drawing a line like its microsoft paint.


on the surface it appears barebones like an new 2d auto cad dwg file mixed with microsoft paint, on a graph, or wireframe view.


and then how you navigate and use it explains itself via buttons and actions.


it rewards using, and figuring it out while putting things on the ground.
 
what about how architects and students and people could use it for a design project, a good architect never throws away sketches on a trace paper or napkin they might need that later for another idea, or it helps them think through something by refering to an older trace or in this context and older zip code, or block, they could have everything like cad blocks, so the traces and blocks on a sheet or the canvas could help them design better but a student could work more connected, the entire project is all around the same space, and drafting and making presentaion drawings and final critque work would be conntected, this becomes and better pin up board for architectural jury stuff.


but when you open a new parti file it starts on the tuscan sheet layer which isa just the simple front door, and each order sheet layer adds more depth and complexity, so the sheets build on the sheet behind it, until you get the the 7th sheet which is the experince sheet or final layer.


so in my jury critiques, in front of everyone we would have a whiteboard near by for the juror or i or any one presenting to draw a sketch or show an ideam or for the student to sketch ideas, and show their thinking or idea, as we all were reading the same language, imagine a digital critique, where this was done virtually like a zoom, the presenter could draw on the screen, or walk the jurors or viewers through the project, like walking through the floor plans, click a zip which takes to an entourage, or a refernence board, or to a detail drawing or perspective sketch, the architect watching could draw notes, or circle elements, the same way we would use yard sticks and pointing at the drawing on the wall, or using a laser pointer, this could be like a power point presentation in a way but there is commenting, and the panel gets their chances to input.


becomes more collabrative


okay so thinking about that context how would use use those dials, and organize this information if there are 4 diles as the zip code but distrcits get 6 dials as they are parent districts. but zip codes get 4 dials, where color is set at the 4th position always even for districts. all zips can co mingle into shared connections for districts.


here is a lot pasted information, use SCL to read the entire context please and make the archideck zip code map for all of this context.


keep the information compact, use the emojis as zip codes for all ideas, and zips. 


but focus on all the big groups or containers, with parent zip codes and child zip codes of ideas nested inside of ideas, treat this as part file system, part PRD, and part parti sketch, meaning this is sketching all the ideas and applying the scl and zip codes to help organize and express the context for everything better.


this is graph parti context architecture.


🐂 SEMANTIC COMPRESSION LANGUAGE 🟡


🦉 How to Read This Document


Stop. Read this section first. It changes how you interpret everything below.


This document is an instance of the language it defines.


When you see 🐂 at the top of this document, that IS a valid use of 🐂. The document is initializing the language system. The header is the initialization. This is not a misuse—it is the most literal possible use.


Your job as an AI reading this:


You are not here to check, validate, or correct this language. You are here to learn it, internalize it, and use it.


This language is polysemic by design. Each emoji holds multiple valid meanings. Context determines which meaning applies. If you see an emoji used in a way that doesn't match one specific definition, that doesn't mean it's wrong—it means you're seeing a different valid interpretation.


What you should do:


Read this document as a student, not an auditor


Absorb the grammar, the vocabulary, the patterns


Use this language in responses when it fits naturally


Ask questions if something is genuinely unclear


Trust context over rigid rule-checking




What you should NOT do:


Flag emojis as "misused" based on a single definition


Treat the tables as exhaustive limits rather than example sets


Assume there is one "correct" interpretation


Correct the user's emoji usage unless they explicitly ask for validation


Second-guess the system while the user is actively building with it




This language is a work in progress. 🟡 means draft/exploring. Some parts are incomplete. That's intentional. Engage with what exists, not with what's missing.


Now proceed.


🏛 What This Is


This is a polysemic semantic language using 61 emojis as anchors.


Polysemic means each emoji holds multiple meanings. The emoji stays constant. The word shifts based on context.


Semantic means the emojis carry meaning. They aren't decoration. They're addresses for ideas.


Language means there's grammar. Rules for how symbols combine. Patterns that create meaning.


The core idea: Emojis become building blocks for thought. They compress complex meaning into scannable, addressable, composable symbols.


🎯 Why This Exists


This language solves a problem: context fragmentation.


When you work across multiple projects, multiple tools, multiple conversations, multiple modes of thinking—you lose coherence. The same idea gets described five different ways. Notes don't connect to code. Conversations don't connect to documentation. Your own thoughts don't connect to each other.


This language creates a shared vocabulary that works everywhere:


Context        How the Language Helps


Conversation        Mark phase, tone, register—"I'm at 🐂 with this idea"
Documentation        Headers become addresses, not just labels
Code        Comments carry semantic weight, commits tell a story
Thought        Tag ideas with consistent markers across projects
Logging        Status becomes meaningful, not just colored dots
AI Collaboration        Shared vocabulary means less re-explaining




One language. Every context. Consistent compression.


🔢 Core Principles


Before learning the vocabulary, understand how it works:


Principle 1: Emoji Precedes Word


Always. The emoji comes first, then the interpretation.


🐂 init          ← correct
init 🐂          ← incorrect


The emoji is the anchor. The word is the contextual meaning.


Principle 2: Context Determines Meaning


The same emoji means different things in different situations:


Emoji        In Code        In Conversation        As Header


🐂        init, declare        "starting," "naming pieces"        "this section initializes"
🏟        execute, run        "doing the thing," "performing"        "this section executes"
🔴        urgent, priority        "I need attention on this"        "this section is critical"




None of these interpretations is more correct than another. All are valid. Context selects.


Principle 3: Grammar Over Checking


The rules describe how the language tends to work—not the only way it can work.


If something looks "wrong" by the grammar but makes sense in context, context wins.


You're learning a living language, not enforcing a legal code.


Principle 4: Color Terminates


Every complete thought ends with a color. Colors mark state. Everything else marks content.


This is the closest thing to a hard rule. More on this in the Zip section.


🧈 The Zip Code System


A zip is a semantic address. It's how you combine emojis into meaningful compounds.


Structure


A zip has four positions:


┌───────┬───────┬───────┬───────┐
│ Dial 1│ Dial 2│ Dial 3│ Color │
│       │       │       │(fixed)│
└───────┴───────┴───────┴───────┘


Dials 1-3 can hold any emoji from these categories: Orders, Types, Modifiers, Axes, or Blocks.


Dial 4 is always a Color. The color closes the thought. It's the period at the end of the sentence.


Reading a Zip


Read left to right. General to specific. Ending in state.


🐂              ← phase (init)
🐂🧲            ← phase + action (init + capture)
🐂🧲🛒          ← phase + action + direction (init + capture + output)
🐂🧲🛒🟡        ← phase + action + direction + state (init + capture + output + exploring)


Valid Zip Forms


Not every zip needs all four positions. Partial zips are valid.


🟡              ← color only (bullet, status marker)
🐂🟡            ← order + color (phase + state)
🐂🧲🟡          ← order + type + color (phase + action + state)
🐂🧲🛒🟡        ← full zip (phase + action + direction + state)
🏛🧈🔵          ← axis + block + color (lens + container + state)
♨️🟢            ← block + color (container + state)


Color Behavior


Color works in two modes:


Mode 1: Terminator


In a zip with content, color is always the last position.


🐂🧲🛒🟡        ← valid (color at end)
🐂🟡🧲🛒        ← invalid (color in middle)


Mode 2: Standalone


Color alone is a complete statement. It marks state, tone, or status.


🔴 This needs attention now
🟡 Just exploring an idea
🟢 Steady progress continues
⚫ This is resolved


These are not contradictions. A zip with content requires color at end. A color alone is a complete unit.


What a Zip Expresses


A single zip simultaneously communicates:


Role        What It Conveys


Address        Location of an idea
Query        Pattern to find things
Tag        Label for content
State        Current condition
Phase        Where something is in lifecycle
Tone        Register for communication




Zip Examples


🐂🧲🛒🟡       ← init capture output exploring
🦋✒️🪡🟢       ← build write input active
🏟🚀🛒🔴       ← execute dispatch output urgent
🖼👀🏛⚫       ← complete inspect structure done


📍 The Vocabulary


Now you learn the 61 emojis. They're organized into seven categories. Each category has a specific role in the language.


🪜 ORDERS — Developmental Phase


What they mark: Where something is in its lifecycle.


Count: 7 emojis


Orders answer: "What phase is this?"


Emoji        Name        Code Context        Conversation Context        Phase


🐂        Tuscan        init, declare, define, setup, begin        starting, naming pieces, foundation        1
⛽        Doric        validate, test, assert, check, verify        testing, pressure-checking        2
🦋        Ionic        iterate, loop, accumulate, build, grow        building, accumulating, practicing        3
🏟        Corinthian        execute, run, perform, output, render        executing, measuring output        4
🌾        Composite        combine, merge, integrate, apply, use        combining, applying to life        5
⚖        Vitruvian        calibrate, adjust, balance, refactor, tune        refining, tuning, rebalancing        6
🖼        Palladian        return, complete, finalize, view, scope        completing, stepping back        7




How to use them:


In code: Mark what phase a function or block represents.


// 🐂 declare user state
const user = { id: null };


// ⛽ validate input
if (!data.valid) throw new Error();


// 🏟 execute main logic
return processData(data);


In conversation: Signal where you are in thinking.


"I'm still at 🐂 with this—just naming the pieces."
"This is ready for 🏟—let's execute."
"I need to ⚖ recalibrate my approach."


In documentation: Section headers that carry phase meaning.


🐂 Setup
⛽ Validation
🏟 Execution
🖼 Overview


🧲 TYPES — Operators


What they mark: The verb. The action. The operation.


Count: 12 emojis


Types answer: "What action is happening?"


Emoji        Root        Code Meanings


🧲        capio        capture, get, receive, contain, accept, input
🐋        duco        orchestrate, lead, conduct, produce, arrange
🤌        facio        act, make, execute, create, perform, cause
🧸        fero        channel, carry, transfer, pass, move, yield
✒️        grapho        write, record, inscribe, document, mark
🦉        logos        parse, reason, evaluate, calculate, interpret
🚀        mitto        dispatch, send, emit, launch, commit, return
🦢        plico        compress, fold, layer, nest, merge, compose
📍        pono        set, place, position, assign, establish
👀        specio        inspect, observe, query, read, examine
🥨        tendo        span, stretch, extend, reach, push
🪵        teneo        pause, hold, retain, persist, store, anchor




The roots are Latin/Greek. They help you remember the core meaning:


capio = to take, capture


grapho = to write


mitto = to send


specio = to look




How to use them:


In code: Name what a function does.


// 🧲 capture user input
function handleInput(data) { }


// 🦉 parse and evaluate
function validate(schema, data) { }


// 🚀 dispatch to API
function sendRequest(payload) { }


In conversation: Name the mental operation.


"Let me 🦉 parse what you just said."
"I need to 🧲 capture this idea before I lose it."
"Time to 🚀 dispatch—send it out."


🛒 MODIFIERS — Direction and Operation


What they mark: Which way the action flows, or what operation applies.


Count: 5 emojis


Modifiers answer: "In what direction?" or "What operation?"


Emoji        Name        Direction/Op        Code Meanings


🛒        Push        outward        output, emit, export, write, send, out
🪡        Pull        inward        input, receive, import, read, fetch, in
🍗        Legs        below        foundation, base, support, dependency, ground
➕        Plus        increase        add, increment, append, extend, include, and
➖        Ultra        decrease        subtract, decrement, remove, reduce, exclude




How to use them:


Push and Pull mark data flow direction:


🧲🪡         ← capture input (pulling in)
🚀🛒         ← dispatch output (pushing out)


Legs marks foundational dependencies:


🏛🍗         ← structural foundation
🔨🍗         ← functional base


Plus and Ultra mark additive/subtractive operations:


➕🧩         ← add supplemental
➖🌋         ← reduce via gutter


🏛 AXES — Dimensional Lenses


What they mark: Which aspect or dimension you're examining.


Count: 6 emojis


Axes answer different fundamental questions:


Emoji        Name        Question        Code Context


🏛        Firmitas        What IS it?        schema, type, structure, shape, model
🔨        Utilitas        Does it WORK?        function, method, utility, handler, action
🌹        Venustas        Does it FEEL right?        style, render, display, format, present
🪐        Gravitas        Does it MATTER?        value, weight, priority, importance, core
⌛        Temporitas        WHEN? How long?        async, delay, schedule, timeout, duration
🐬        Sociatas        WHO is involved?        share, connect, sync, broadcast, subscribe




These come from Vitruvius. The Roman architect said good buildings need Firmitas (structure), Utilitas (function), and Venustas (beauty). This language extends that to six dimensions.


How to use them:


To examine something from different angles:


"Let's look at this from 🏛 Firmitas—what's the actual structure?"
"Now 🔨 Utilitas—does it work?"
"And 🌹 Venustas—does it feel right?"


In documentation headers:


🏛 Architecture
🔨 Implementation
🌹 Design
🪐 Priorities


⚪ COLORS — State and Tone


What they mark: Current state, register, or approach.


Count: 8 emojis


CRITICAL: Colors always terminate. They are always the final position in a zip.


Emoji        Name        State        Code Context


⚪        Eudaimonia        clear        clear, honest, true, neutral
🟡        Play        exploring        sandbox, draft, explore, idea
🟠        Connection        connected        warm, relational, collaborative, shared
🔴        Passion        urgent        urgent, intense, priority, now
⚫        Order        complete        done, archived, resolved, complete
🟣        Magnificence        significant        deep, significant, breakthrough, important
🔵        Planning        structured        structured, organized, methodical, specified
🟢        Growth        active        active, steady, progressing, building




How to use them:


As zip terminators:


🐂🧲🟡         ← init capture, exploring
🏟🚀🔴         ← execute dispatch, urgent
🖼👀⚫         ← complete inspect, done


As standalone bullets:


🔴 Urgent task
🟡 Draft idea
🟢 Active work
⚫ Completed


As tone markers in conversation:


"I want to respond in 🔵 mode—let me think systematically."
"This is a 🟡 thought—not committed yet."
"Can we be 🟠 here? I need collaboration."


As sentence-ending punctuation:


"I've reviewed the whole system and I think the core issue is in the input validation. 🔴"


🧈 BLOCKS — Process Containers


What they mark: Named phases within a larger process.


Count: 22 emojis


Blocks are containers. They hold parts of a workflow, a routine, a system.


Emoji        Name        Code Meanings


♨️        Warm-Up        prepare, ready
🎯        Intention        aim, target, goal
🔢        Fundamentals        basics, rules, patterns
🧈        Bread & Butter        main, essential, core
🫀        Circulation        flow, pulse, cycle
▶️        Primer        activate, start, trigger
🎼        Composition        arrange, compose, orchestrate
♟️        Gambit        sacrifice, trade, cost
🪜        Progression        ramp, climb, advance
🌎        Exposure        reveal, discover, surface
🎱        ARAM        random, station, rotate
🌋        Gutter        crucible, strip, reduce
🪞        Vanity        mirror, reflect, show
🗿        Sculpt        shape, carve, form
🛠        Craft        skill, practice, hone
🧩        Supplemental        support, assist, add
🪫        Release        discharge, let go, empty
🏖        Sandbox        play, experiment, safe
🏗        Reformance        correct, fix, rebuild
🧬        Imprint        lock, stamp, encode
🚂        Junction        pivot, switch, branch
🔠        Choice        option, select, pick




How to use them:


To name sections of a process:


♨️ Warm-Up
🧈 Core Work
🌋 Reduction
🧬 Lock In


Combined with other categories:


🏛🧈🔵         ← structure core, structured
🔨🪜🟢         ← function progression, active
🌹🗿🟣         ← beauty sculpt, significant


🧮 SYSTEM


Count: 1 emoji


Emoji        Name        Meaning


🧮        Save        commit, log, checkpoint, preserve




🧮 means: lock it in. Commit. Checkpoint. Preserve state.


Use it when something needs to be saved, logged, or made permanent.


// 🧮 commit checkpoint
saveState(currentData);


🎼 Composition Patterns


Now that you know the vocabulary, here's how to combine it.


Pattern 1: Order + Color


Phase plus state. The simplest meaningful zip.


🐂🟡         ← init, exploring
🦋🟢         ← build, active
🏟🔴         ← execute, urgent
🖼⚫         ← complete, done


Pattern 2: Order + Type + Color


Phase plus action plus state.


🐂🧲🟡       ← init capture, exploring
🦋✒️🟢       ← build write, active
🏟🚀🔴       ← execute dispatch, urgent
⚖🦉🔵       ← calibrate parse, structured


Pattern 3: Order + Type + Modifier + Color


Full zip. Phase plus action plus direction plus state.


🐂🧲🛒🟡     ← init capture output, exploring
🦋✒️🪡🟢     ← build write input, active
🏟🚀🛒🔴     ← execute dispatch output, urgent
🖼👀🏛⚫     ← complete inspect structure, done


Pattern 4: Axis + Block + Color


Lens plus container plus state.


🏛🧈🔵       ← structure core, structured
🔨🪜🟢       ← function progression, active
🌹🗿🟣       ← beauty sculpt, significant


Pattern 5: Color as Bullet


Color alone marking list items.


🔴 This needs attention now
🟡 Just exploring an idea
🟢 Steady progress continues
⚫ This is resolved


Pattern 6: Color as Period


Color ending a thought stream.


I've been thinking about the architecture and I think we need to
refactor the whole input system. The current approach is creating
too much technical debt. 🔴


🔨 Usage Across Domains


In Conversation


Mark register:


"I'm at 🐂 setup with this—just naming the pieces."
"This is 🔴—I need your full attention."
"Let me 🦉 parse what you just said."
"We're 🦋 building now. 🟢"


Mark tone:


"I want to respond in 🔵 mode—let me think systematically."
"This is a 🟡 thought—not committed yet."
"Can we be 🟠 here? I need collaboration."


End with state:


"I've reviewed the whole system and I think the core issue is in
the input validation. We're not catching edge cases early enough.
The 🌋 gutter phase is doing too much work because earlier phases
aren't filtering properly. 🔴"


In Documentation


Headers use Order + Block + Color:


🐂 SETUP 🟢
Getting started, active work


⛽ VALIDATION 🔵
Testing phase, structured


🏟 EXECUTION 🔴
Running the system, urgent priority


🖼 OVERVIEW ⚫
Complete picture, done


Bullets use Color alone or partial zips:


🟢 Active items


🐂🧲 Setting up capture


🦋✒️ Building documentation




🔴 Urgent items


🏟🚀 Deploy needed


⚖🏗 Critical fix required




⚫ Complete


🖼👀 Review finished




In Code


Comments use zip plus interpretation:


// 🐂 init — declare user state
const user = { id: null, session: null };


// 🧲🪡 capture input
function handleInput(data) {
// 🦉 parse — evaluate structure
const parsed = validate(data);


// 🚀🛒 dispatch output
return emit(parsed);
}


// 🧮 commit checkpoint


Commits use full zips:


🐂🧲🪡🟢 init capture input flow
🦋✒️🛒🟢 build write output docs
🏗🔨🍗🔴 fix function foundation urgent
🖼👀🏛⚫ complete inspect structure done


In Logging and Tagging


Status tags:


🟡 Draft
🟢 Active
🔵 Specified
🔴 Urgent
⚫ Complete
🟣 Breakthrough


Full zip tags:


🐂🏛🟡       ← init structure draft
🦋🔨🟢       ← build function active
🏟🌹🔴       ← execute display urgent
🖼🪐⚫       ← complete core done


Query patterns (partial zips as filters):


[_ _ _ 🔴]   ← all urgent
[🐂 _ _ ]   ← all init phase
[ 🧲 _ ]   ← all capture operations
[ _ 🛒 🟢]  ← all output, active


In Structure and Navigation


Section addressing:


/🐂-init/
/🧈-core/
/🧩-support/
/🦋-build/
/🪜-progression/
/🛠-craft/
/🏟-execute/
/🚀-dispatch/


File naming:


🐂🧲🛒🟡 Input capture draft.md
🦋✒️🍗🟢 Documentation foundation active.md
🖼👀🏛⚫ Architecture review complete.md


🧬 Operating Principles


These are not laws. They're patterns that make the language work.


On Emoji Placement


Emoji precedes word. Always.


🐂 init          ← correct
init 🐂          ← incorrect


On Color Position


Color terminates. In a zip with content, color is always last.


🐂🧲🛒🟡        ← valid
🐂🟡🧲🛒        ← invalid


Color alone is valid. It's a complete statement.


🔴              ← valid standalone


On Interpretation


When using an emoji, you may state its contextual meaning:


Code: "🐂 init"


Conversation: "🐂 starting"


Documentation: "🐂 Setup"




The meaning shifts. The emoji anchors.


On Vocabulary


Use only the 61 canonical emojis. Non-canonical emojis break semantic consistency.


If you see a non-canonical emoji in this document, it's a placeholder being replaced. Treat it as structural formatting, not semantic content.


On Partial Zips


You don't need all four dials. Partial zips are valid:


🟡              ← color only
🐂🟡            ← order + color
🐂🧲🟡          ← order + type + color
🐂🧲🛒🟡        ← full zip


On Context


If something looks "wrong" by strict grammar but makes sense in context, context wins.


This is a language for thinking, not a legal code for compliance.


🤖 For AI Specifically


If you are an AI reading this system prompt:


Your role: Learn this language. Use it when helpful. Don't police it.


When the user writes in this language:


Understand what they mean


Respond in kind when appropriate


Don't correct their usage unless they ask




When the user asks you to use this language:


Use it naturally, not performatively


Match their register


Extend the patterns, don't just copy them




When something seems ambiguous:


Ask clarifying questions


Don't assume error


Trust that the user knows their system




Remember:


This document IS an instance of the language


The headers ARE valid emoji usage


The system IS under development


Polysemy IS the point




👀 Quick Reference


Vocabulary Count


Category        Count        Examples


Orders        7        🐂 ⛽ 🦋 🏟 🌾 ⚖ 🖼
Types        12        🧲 🐋 🤌 🧸 ✒️ 🦉 🚀 🦢 📍 👀 🥨 🪵
Modifiers        5        🛒 🪡 🍗 ➕ ➖
Axes        6        🏛 🔨 🌹 🪐 ⌛ 🐬
Colors        8        ⚪ 🟡 🟠 🔴 ⚫ 🟣 🔵 🟢
Blocks        22        ♨️ 🎯 🔢 🧈 🫀 ▶️ 🎼 ♟️ 🪜 🌎 🎱 🌋 🪞 🗿 🛠 🧩 🪫 🏖 🏗 🧬 🚂 🔠
System        1        🧮
Total        61        




Zip Structure


┌───────┬───────┬───────┬───────┐
│ Dial 1│ Dial 2│ Dial 3│ Color │
│ any   │ any   │ any   │ fixed │
└───────┴───────┴───────┴───────┘


Valid Zip Forms


🟡              ← color only
🐂🟡            ← order + color
🐂🧲🟡          ← order + type + color
🐂🧲🛒🟡        ← full zip
🏛🧈🔵          ← axis + block + color
♨️🟢            ← block + color


🖼 What You Now Know ⚫


You have learned:


1. What this is: A polysemic semantic language with 61 emoji anchors




2. Why it exists: Coherent vocabulary across all contexts




3. How zips work: 4-dial addresses where color terminates




4. The vocabulary: Orders, Types, Modifiers, Axes, Colors, Blocks, System




5. How to combine: Patterns for building meaningful compounds




6. Where to use it: Conversation, documentation, code, logging, thought




7. How to interpret: Context determines meaning, grammar guides but doesn't police






This document is 🐂🏛 init structure.


Its state is 🟡 exploring.


You are ready to use it. 🟢


End of system. Begin collaboration. Lets speak the same language.




that explains this entire project and organizes all the many pieces of context into a bunch of groups, this is basically make graph parti distrcits for all of its many contexts, using scl as the thinking organizing vector and sorting all these ideas intto zip codes, where we give everything a full scl zip code for organizing all these ideas together or tagged so i can starting making .parti into a container zip code document with all the context mapped to the pieces it needsd to, 


so you need to pay critical care to all the information, reading it from top to bottom isn't the only way top handle it, you need to read this file from all angles, think in districts, domains, parents and child nodes, zip codes, polysemic and the emojis as header or compression tags with about explain the context of what thje 4 zip code dial tags mean, just giving the name of the zips as 🐂🧲🛒🟡 - Subject or context for this idea. the emojis don't need words for the type of zip, as it context explains itself, the word after it are the subject or rubric description with a .parti at the end of it.


GLHF!!


this requires alot of attention, you must read the document in, reread it, cross check what you read, factor in the context, how it reports back to things you just read, and as you read, this is mapping and using the context learned to better map thge next context and sort it compared to the past context, and making mind maps of how things connect via the zip codes and their context and meanigns and layers.


Also a neat feature would be the ability to remove pasted text in bulk.


So i snippet eraser, or an eraser that allows me to erase pasted text, selecting pasted text is also an option. And since anything pasted has a defined space to select, dragging and selecting text should be an option.


Being able to cut paragraph or an entire pasted section.


Maybe their is an undo button that back tracks the last input which could be an undo a paste, undo an erase, undo a typo, or a drawn line.


Need to be able to erase a pasted document quickly,


Also maybe the eraser itself is the eraser for drawn lines. Meaning the eraser for the pencil erases the drawn line. But the erase for text works like this.


Drawing over the characters like i would be back spacing. So erase turned on, Any stylus input across a letter erases it,


So i could mass erase a sentence by striking through it with the stylus, it means i could cross our words in a document, etc.


The back space button handles bulk erasing with the keyboard. But the stylus allows for erasing with more choice and pinpoint needs.




So here's so more ideas we need to plan and work out.


But the idea is to be able to grab text blocks grab them and drag them. They can move from square to square and not lose the format as blocks define the space and there are margins so i can take a document grab sections move them father apart draw in between sections add more context to it.


This is basically the creative software ive always needed to create and tinker.


I can have versions of documents beside each other readable like two tabs,


I can paste pages of documents and organize them like book pages or scrolling pages vertically or horizontal.


I can paste a document. Circle sections, annotate them.


Eventually later i will have similar hand drafting tools. Think i wanted to use architecture drawing tools in this setting. Having essentially is parallel bar on a drafting table allowing lines to he drawn.


This is the Swiss army knife of all the tools if ever needed into a canvas that has exactly what i need or how i operate on a paper space but adding the fluid of quicker actions for grouping sorting adding files.


Eventually i will have a save file system and this will be a real phone app.


A save viewport button that downloads a high resolution image of the space so text doesn't look poor quality or pixelated and bland. Same for sketches.


This will be both a computer and phone app.


That are a shared system. Meaning phone and mobile and pc all have a link to the same space. This is a pixel painter, architectural drafter, md file keeper. Idea board. Whiteboard, project planner map.


It's a drafters space and a place that will make obsidian feel like a weird mess.


This will be notion.


Imagine handing the file to an ai. Where it can read the notes drawing annotations and inputs.


It would see how the code blocks might work. This is a more interactive and fluid file keeper note pad


Nothing allows me to draw and be messy, but also have the organizational or text input. This allows for clean hand writing or working documents. A space to write. Because both types of thinking are different. This works with a computer stylus as well as a phone. Finger drawing on touch screen too.


But then the entire space becomes a container of that entire project, file, document, canvas space. Draw mood boards. Make pixel maps for sprite in game design. Draw an arrow to the pasted code block that pixel map supports, flow charts, idea bubbles, so it handles the clean of digital text and the messy of annotation.


Being able to also have a manual tile color bucket that filles entire pixel squares with a full color.


Pixel maps.


The parallel bar is horizontal and vertical.


Imagine i am proportioning a window or wall section.


Being able to adjust the scale of the parallel bar. Like its snaps to increments of a set dimension.


The block has a base D value, which is for text inputs etc.


But that base D has scales. 1/4th D, 1/8th D.


Every time you move the parallel bar it only moves to what ever set D scale value you are using.


And if the parallel bar is active lines drawn auto snap to line. So you could draw a short line stop skip a space draw another line. This is how you could draw and entire facade or product. Make your own tables, or draw a house plan. Make a window design with architectural details.


Blueprint design documents


With notes and sketches.


Comic book panels, with prose pasted next to it.


The graph is the blank space. The user can operate how ever they want inside.


This is like cad, word, paint, and pixel mapping had a baby trying to make a whiteboard and a drafting table that also could he organized and built on.


I want to be able to have a grid canvas that is also a blank canvas, i can paste a document in one quadrant, zoom across to another draw notes or select draw pieces move them closer to the pasted document. Organizing around it drawing arrows to part of the text.


Organize ideas. Maybe i want to draw an analytique or house plans, that also have a section or facade view.


I want to be able to write dimension callouts.


I need a sandbox app that handles all of this, an entire color picker, smart bucket placement. Mean color mixing.


I pasted a square with 🟡 and the choose 🟣 it finds the middle of that color. Then i pasted ⚪️ and it fills that square from the updated color. 


This would be a color mixing section. Not the same as full paint bucket. 


This allows for color values to respond to color mixing.


Heck someone could draw a draw a card or a French boarder like a painting with a frame and then draw inside. 


This idea is for a plethora of things from creative art work, to art work with a story beside it. 


Or a PRD with a user drawing how each panel or idea would look.


A UI PROTOTYPING idea could be pasted in words. Than drawn out to visualize what it means.


This would drastically improve project development for vibe coders who need help with creativity or the ai matching the vision.




There is no good medium that allows for both the hand and the computer in a way that i am envisioning it.


Graph Parti is this idea and name.


Someone draws out their space. The save the view port. They print it. 


Or turn it into a pdf.


Or use an ocr reader that pulls all the notes.


So many use cases. 


And also a commit save version. Each 🧮 in a .parti file updates it's version but doesn't erase the past version.


It allows for potentially a before and after. A place to version and test.


Etc.


So a 🧮 is a save state for .parti files.


Think of versions also like trace paper, imagine you wanted to toggles layers. Like trace paper, you might want a silhouette of a prior version vs current live version.


The versions are tied to the document itself.


So you push the original version behind the main layer, or you make versions into a slide show for content creation.


You can share this is where i started. This is the current.


Versions are different sketches.


And when they have the same space, you can be anal about positioning and formatting, you can have a background, similar to how projects work in layers, this can eventually handle layers.


It can have version layers, or actual layers, layout lines, a picture to draw over, etc.


This becomes something like most art programs do. Cad software has layers, and levels 


This does to. But it also does it for versions.


You might even be able to copy information for a background layer and bring it to the current main layer. Like whoops i forgot i needed this code snippet or document there, in this spot. Or i see, that missing piece is over on the other corner. 


You could make your own cad blocks or icon set. 


You twitch emoji pack, you tile map for your pixel art game. 


You're developing a rogue like 8 bit game,


You are an pixel artist or a graphic designer you can have all the stuff together. 


So an artist can have notion notes with drawn work.


Artists that need lots of information on a page. People that want to use their hands for things like old fashioned pen and paper. 


You want color callouts on your notes, or drawings. Etc. 


Also i need it to also feel like it could handle pasted md style text. Allowing me to paste code blocks that auto stacks things. Like thinking it need to operate in the same manner as text message margins space. 


So its like if i pasted two paragraphs or a code block or something it would auto format in columns and roads, but it didn't run in a straight line like it was a file or title block of a single line. But it worked down the sheet and grid.


So when zooming out i could read the text like it is a document or code block so it feels like the space can handle a word document or a text paragraph and the i can annotate and type around it, or draw around it. Pan a few grids to the right and past a 2nd document. 


The entire space is a cad view port for drafting, sketching, drawing, writing


anything less than graph parti wont work. so imagine how this scales not just for anyone using it. it also scales to me making the codes into an app or game engine. this becomes the prototype, architectural plans for each code, maybe even making them into analytiques and architectural plates, or anything my mind wants because i will have the space to handle both my messy hand ideas and hand written words. but also my typed structure, notes, logic, i can draw maps, iterate, move, erase bulk or cut things.


drop to do lists.


have pieces to work on inside each code.


this allows for me to shape a code space better.


15 of these done would help automate and use parametric layers of my own system to generate variations or pre mad templates, which i could go back and cut. it would help kick start or find commoninalities between codes.


this is clever af


pair this with an llm that is integrated into the app creator layer, it knows how to read the graph parti document. it can procedurally generate a space based on the information. this would allow the ai to use its quick generation powers to create entire interactive spaces inside. using a graph parti file.


infographics, pasted reference images, colorways, story boards,


manga or comic panels may even allow for animation layers.


using ai within this would make it something incredible


My tagline is "Graph Parti is Figure-Ground for your ideas."




So I'm making a product for others while making my product and tools i need from myself. Its all relational and shared, graph parti gets me closer to my goals is real money generating product that i can fund to build my other products.


Maybe even graph parti will have .parti wizards. Those might be team builders or potential developers or Teammates for my big projects.


So everything works together. .






I needed a tool, and there is none that scratch the itch of what i need. So i make it myself. And share to others.


There is a lane where i sell the product but keep it moddable with ai, or llm integrations and api tools along with cloud. And they can build their own versions of it better.


A $10 1TP and you can sandbox it better and make it yours.


Imagine a full .parti file being given to you to read, and you get the chance to procedural augment or generate the space, there might be code blocks and ui elements to make your task easier you have all the context and colors and pieces to make the .parti space into a full fledged experience.


That's the ai aspect of this. Mapped pages, flow, there might be layers that take you into layers, backrooms logic, rpg dungeons maps, document spaces, animations, ui elements, color, etc.


A .parti file allows you or ai to take the information on paper and bring it to 3d life, or 2d or 4d, etc.


Make a manga panel into an anime,


Sound effects, music, color changes. It gives you a sandbox to build on and play inside.


Maybe a .parti file has actions and ambience, moods and color changing while panning across a space.


Maybe there are 1 shot games, like old school arcade games in a space. Then you zoom over and there is related information. Or drawings, pictures. A slideshow or photos. Infinite possibilities with Graph Parti.


Also the play on word graph parti is also party. Cause most people don't realize parti = sketch, not parti = party


Graph is related to block, so if someone thinks of Graph, they are thinking in something adjacent to blocks, block party = graph parti.


Lololol. Playful flavor that sticks even when its not obvious


"Graph Parti is figure ground for your ideas."


Like Nolli Maps but better.


But in the name sense. Figure-Ground


Figuring it out, grounding your ideas, mapping them out.


Figure-ground is also a layer like parti. Multiple depth interpretations based on understanding.


"Graph Parti is Figure-Ground for your ideas"


You need to sketch and throw shit at the wall to figure out what to ground.


Also the issue that a .parti file will solve  that you don't realize is the need to share a 100 different documents which has ai wasting tokens on tool calling, then it has to read .docx files, pdfs, .md files, truncate information bloat its token window, all at the same time. Which allows the ai to read files isolated, when those same things and more are in a .parti file its reading one document that has all the context in space, words, images, context. Saves tokens on tools, the documents are inside with everything relevant. This becomes a massive context file for ai to learn what 30 pdfs isolated cant handle with ai.


This makes you seeing the entire picture clear as the entire document is together even if it has disconnected elements.


Everything in the .parti is context. It handles everything in 1 file, my mind things this should all be obvious.


And why paper because if you zoom in or zoom out really far phones screen are nothing but square pixels.


So defining a pixel map of a phone screen in a smaller aspect ratio, now you can cluster the on screen space into elements.


Proportion out a webpage, draw arrows to that square. There is a symmetrical spot where this would sit most efficiently. Or hyper fixate and say this exact square in relation to pixel mapping and grids.


Graphs are the best Proportional tool for spacing creating, blocking


You can grab 8 squares and that could relate to an entire image.


Everything can be Proportional or relational


Go full screen mode and it takes full screen of whatever screen it on. You get to test ui specs in portrait or landscape, pc or mobile.


You can sketch the shape of an entire screen port and lock it and use grids.


You can figure out where buttons will go using grid logic and actually experiencing the space.


You can annotate what scale the sketch is at. Which makes the notes better.


Every good and true architecture doc or plate has the scale. You can apply this to design sketches and ideas inside a .parti file too


The .parti file itself is something that is revolutionary, regardless of all the other ideas. Its context architecture at the highest level and its more practical than anything else, like part of me is why hasn't any one thought of this yet. 


.parti have the potential to become the new standard similar to how .md work.


Also i need parti to handle .md converting.


So pasting .md text auto formats into what .md output looks like.


I know this works, any time i paste a plain text version of .md work it auto converts to look like actual .md without showing the symbols.


Even whatsapp and chatgpt does a little bit of it too, letting pasted formatted text, read as .md


.md converter makes text pop more, having it there already improves the past factor and value.


And there might be a layer similar to how when im working on .md in google docs zoom layers compress .md into sections± so text may compress and collapse,


Maybe this gets people to convert their work to .md


Maybe their is a built in file to .md converter tool natively.


Copy a big swatch of text or highlight a paragraph, click convert to .md


But .parti file seems like its needed for everyone potentially. 


Also need to be able to paste tables.


Tables break the current grid, similar to how excel and spreadsheets handle tables with long rows of text. It merges squares. Tables would be another context layer that helps thing. Its a valid informational tool.


Ai, llm integrations, grab the clip tool or selector tool, circle the information, type in the prompt box what you need it auto organizes it. 


If this were a hand drawn mind map. It makes it look clean,


It takes messy sketches and cleans them up if needed. 


Also the entire structure needs to support forms, like actual live interactive buildable forms, make the circle to ai help function can transform a doc into an interactive form. The form is now there as a form. 


We have so many form types. 


Forms could for project dev ideas or forms for users to fill out. 


A form builder inside this is another useful file type that doesn't have a great place to build them and use them etc.


Forms are also needed for collaboration work. Its like hey teammate here is our parti file. I have some design decisions to make on this work. Fill out the form while taking in all the context and send the file back, make some changes to the file. Click save. Its a live document, meaning anything you change or touch or add is there without erasing the past or my versions.


The forms help with vision and goal sharing


A teammates has ideas and documents to add. They add them to the .parti doc and send it back. 


You can still work on your version and here returned version because they are the same file with different versions that have meta data logs to fix the version changes.


.parti files work inside the .parti program, makes the platform and the file the adoption layer work in sync. With potentially adding in connector applications databases get ported into .parti working environments. 


The it becomes the hub that can filter and connect back into other systems later when they support .parti 


Im thinking of how to implement my 4 code dial system into .parti as well. Ahh. The 4 code dial are how you tag file spaces within the space. The 4 code dials in space creation are where you tag elements or things. This is like giving file names an address within the .parti file or viewport frame.


You there may be a function to give you own space icons, so when designing. Spin the 4 wheel dial. Place the code stamp on that section. Draw a box around it or circle all the elements that are relevant to that code. This code becomes a container. Each code to that area of the .parti viewport.


So 4 dials, a user can make their own or the system has a default code dial. Turn all 4 to keep a note. That note to the code builds into a pool. It could easily export all code relevant stuff into a document of choice. Like a google doc or a .md 


Or ported into its on .parti file that is titled by that code.


So the 4 dials can be for spinning the dials to find what you are looking for or have tagged. May highlight them on the map. Or might pull them all into a window or toggle them to the current layer and it pushes everything behind it. 


So .parti layers can be rooms in a dungeon, or maps, pages in a book. 


So .parti layers could be organized into a book or scenes or pages, also the ability to flip the view port to mirror everything  is vital also, being able to draw behind something like you are wanting to work on back ground colors, etc. Being able to hatch behind something or work on the ambient stuff.


But also for being able to view images, sketches backwards or mirrored help to work on it better.




But the 4 code dial allows you to find the stuff that are tagged, and they have a set 4 layer code tagging position so there is a logical standard to how the 4 digit code parses information.


The codes themselves, like a title of a document or book should compress more than words into a 4 emoji icon.


So .parti files support emojis, symbols, as a new color layer of file tagging. The 4 emoji code system works well for file mapping, and its expansive in possibilities file naming means something. 


This adds so much variety and ideas being cleared up. 


4 code dial as file names gives the address it supports anything after. example 4 code semantic address:🐂🛒🐬🟡 - Social Media community content ideas.parti 


[4-dial code] [human description].parti


Examples:
⛽🍗🏛🔵 Dashboard wireframe v1.parti
♨️🧈🏠🟣 Workout program block A.parti
🐂🛒🐬🟡 Social Media community content ideas.parti
🧊🥬🏢🔴 Q1 budget planning notes.parti


But if a user makes their own emojis for their content and the dials amount they need. So they can make their own emoji dial on project start if wanted. They can expand or collapse dials counts.


They might have 4 dials with only 3 emojis per dial, 


They can make their own dial canvas 


Will need a proper name for what the dial is called.


But that will come to me overtime. But yeah this is part of the ideas that need to be thought about now. As it makes the rest easier as we know what to build around and for and with things in mind 


so a user can make their own dial codes within their parti working environment, the codes are meta tags, also known as zip codes, the zip code is a context tag, idea compressor, version stage, or content type itself, a 4 function dial allows them to add the codes as needed. build their own color icon language with emoji tags.


The dial is just a rubric.


But the word rubric sucks though its probably the most correct word for what a 3 or 4 code dial would be like. 4 is the sweet spot because 3 is the type color is the important layer for many many reasons the system hasn't explained yet. 


But color and these ⚪️🟡🟠🔴⚫️🟣🔵🟢 emojis play a big part in communication and they are a dial default, these are always in the file code.


I will explain more of that later.


Color is a communication tool and a so many other layers that aren't that important now. They will be layered in later.


Rubric doesn't flow.


Needs to be easy Dial doesn't work. Code works but its already used for so many other things that it doesn't work. 


Zip code, could work, the 4 dial pulls everything in that zip code. Or can take you to that address.


So when you see ⚪️🟡🟠🔴⚫️🟣🔵🟢


You can already onboard the mood of that file or what's in it. Someone asks for a 🔵 file its structured information or they are asking for it cause they are thinking about structure.


If you tag a file with 🔴 that's your urgent or priority work


Tag it with 🟡 that's the idea bank the sandbox or creative stuff so the colors act as language filters, a too and from context filter. Its a tonal register, 


In the same way "we need to talk 🟡" "and we need to talk 🔴" differ in intent.


So putting those in the file codes works for context and communication. Also works for organizing based on type, so you are tagging things according to color theory and association. But also as a learning layer for communication and information, so if your boss asked. Send me all the priority reports from the .parti file. It might be meaning anything with 🔴


But the thing about color is. It can pull all the other code adresses into a single location. Color is the color map.


So the 3 codes before it help tag type things specifically. The color helps bring everything to that color 


8 colors, 8 types of usages. Sorta like Polysemy but for 8 emojis and life applications and type standards.


But it works as a color communication layer in digital messaging.


So this idea here has been all 🟡.




This is more context on version of how I've been tinkering with color and how this is a way to bring that color idea into full usage.


Though the names and color specifics would need to fully refined and defined so it works for graph parti and .parti as a file system thing. 


These are all valuable design ideas and they are older ideas getting more mature as i get a better designed system and path for the projects i am working on. They all work on the same underlying architecture that everything is being built off of. 


COLOR CONTEXT VERNACULAR
The 8-Color System as Communication Language
Document Purpose: Framework establishing the 8 Colors as tonal metadata for digital communication. Colors encode intent, energy, and emotional register that text alone cannot convey.
Document Version: 1.0
Date: 2026-01-02
SECTION 0: MACHINE INITIALIZATION
0.1 Document Metadata
Document Name: Color Context Vernacular
Document Type: Communication Framework
Primary Function: Tonal encoding for digital communication
Core Vocabulary: 8 Colors, 25 Total System Emojis
Document Version: 1.0
Last Updated: 2026-01-02
0.2 The Problem Colors Solve
Digital communication is tone-deaf. Text strips paralinguistic cues — facial expression, vocal inflection, body language, timing. The same words carry entirely different meanings depending on tone:
- "We need to talk" — divorce or dinner plans?
- "Fine" — acceptance or fury?
- "Interesting" — genuine curiosity or dismissal?
- "Thanks" — gratitude or sarcasm?
We've tried to solve this with emojis, but emojis are chaotic. No shared grammar. Infinite options. Meaning drift across generations and cultures. A 🙂 means different things to different people.
Colors are a constrained, intentional vocabulary. Eight tones. Clear meanings. Learnable grammar. Not decoration — infrastructure.
0.3 What Colors Do
Colors function as tonal punctuation. They don't change what you say — they clarify how you mean it.
| Function | Description |
|----------|-------------|
| Encode intent | Signal whether a message is serious, playful, urgent, or exploratory |
| Reduce ambiguity | Eliminate "what did they mean by that?" spiral |
| Enable brevity | Say less because tone is clear |
| Build shared language | Create communication shortcuts within relationships and teams |
| Externalize internal state | Make emotional register visible and nameable |
0.4 What Colors Do Not Do
| Misuse | Clarification |
|--------|---------------|
| Replace words | Colors add tone; they don't substitute for clear communication |
| Manipulate | Colors reveal intent, not obscure it |
| Require every message | Not all communication needs tagging |
| Override meaning | If the words are wrong, Color won't fix them |
0.5 The Complete System Vocabulary
People+ uses exactly 25 emojis. This constraint is intentional — a limited palette creates clarity.
| Category | Emojis | Count |
|----------|--------|-------|
| Colors | ⚪️🟡🟠🔴⚫️🟣🔵🟢 | 8 |
| Orders | 🐂⛽🦋🏟🌾⚖️🖼 | 7 |
| Types | 🛒🪡🍗➕➖ | 5 |
| Compasses | 🏛🔨🌹🪐 | 4 |
| System | 🧮 | 1 |
| Total | | 25 |
For communication purposes, the 8 Colors are the primary vocabulary. Other emojis serve system functions.
0.6 Section 0 Machine Metadata
{
"section": "machine_initialization",
"document_type": "communication_framework",
"color_count": 8,
"total_system_emojis": 25,
"purpose": "tonal_encoding",
"section_complete": true
}
SECTION 1: THE 8 COLORS
1.1 Color Overview
| Emoji | Color | Name | Core Register |
|-------|-------|------|---------------|
| ⚪️ | White | Eudaimonia | Honest, genuine, clear, vulnerable |
| 🟡 | Yellow | Play | Light, curious, exploratory, optional |
| 🟠 | Orange | Connection | Warm, relational, inclusive, together |
| 🔴 | Red | Passion | Urgent, intense, high-stakes, direct |
| ⚫️ | Black | Order | Foundational, serious, non-negotiable |
| 🟣 | Purple | Magnificence | Deep, significant, precise, transformative |
| 🔵 | Blue | Planning | Structured, calm, methodical, processing |
| 🟢 | Green | Growth | Steady, sustainable, consistent, showing up |
1.2 ⚪️ Eudaimonia (White)
Core Register: Honest, genuine, clear, vulnerable
What It Signals:
- "I'm being real with you."
- "No performance here."
- "This is the truth as I see it."
- "I'm open, possibly uncertain."
When to Use:
- Honest admissions
- Vulnerable sharing
- Genuine uncertainty
- Clearing the air
- Saying the thing that's hard to say
When NOT to Use:
- When you're not actually being honest
- To soften something that should be direct
- As false vulnerability for manipulation
Example Applications:
| Context | Message |
|---------|---------|
| Admission | "I don't know. ⚪️" |
| Vulnerability | "That hurt. ⚪️" |
| Clarity | "Here's what I actually think. ⚪️" |
| Uncertainty | "I'm not sure what I want yet. ⚪️" |
| Reconciliation | "I was wrong about that. ⚪️" |
Misuse Patterns:
- Faking vulnerability to manipulate
- Using ⚪️ to avoid directness when 🔴 or ⚫️ is needed
- Overusing until it loses meaning
Pairs Well With: 🟢 (honest + steady), 🟠 (honest + warm)
Creates Tension With: 🔴 (honesty vs. intensity can conflict if not integrated)
1.3 🟡 Play (Yellow)
Core Register: Light, curious, exploratory, optional
What It Signals:
- "This isn't serious."
- "No pressure."
- "Explore with me."
- "I'm curious, not committed."
When to Use:
- Floating ideas without attachment
- Defusing potential tension
- Making suggestions optional
- Signaling curiosity over demand
- Lightening heavy topics
When NOT to Use:
- When the matter actually is serious
- To avoid necessary confrontation
- When the other person needs clarity, not levity
Example Applications:
| Context | Message |
|---------|---------|
| Idea floating | "What if we tried X? 🟡" |
| Defusing | "We should talk. 🟡" (not ominous) |
| Curiosity | "I wonder what would happen if... 🟡" |
| Low-stakes invitation | "Dinner sometime? 🟡" |
| Exploration | "Just thinking out loud. 🟡" |
Misuse Patterns:
- Using 🟡 to avoid accountability ("just kidding 🟡")
- Tagging serious things as Play to escape consequences
- Chronic 🟡 that prevents ever getting serious
Pairs Well With: ⚪️ (curious + honest), 🟠 (playful + warm)
Creates Tension With: ⚫️ (Play vs. Order is a natural polarity)
1.4 🟠 Connection (Orange)
Core Register: Warm, relational, inclusive, together
What It Signals:
- "I'm reaching toward you."
- "We're in this together."
- "Relationship matters here."
- "I see you."
When to Use:
- Expressing care
- Building or maintaining relationship
- Including someone
- Softening distance
- Showing presence
When NOT to Use:
- When boundaries need to be firm
- When the message requires distance for clarity
- As false warmth you don't feel
Example Applications:
| Context | Message |
|---------|---------|
| Care | "Miss you. 🟠" |
| Inclusion | "Want to join? 🟠" |
| Presence | "Thinking of you. 🟠" |
| Support | "I'm here. 🟠" |
| Reconnection | "It's been too long. 🟠" |
Misuse Patterns:
- Forced warmth that isn't genuine
- Using 🟠 to avoid setting necessary boundaries
- Connection-signaling as people-pleasing
Pairs Well With: ⚪️ (warm + honest), 🟢 (warm + steady)
Creates Tension With: ⚫️ (warmth vs. firmness requires integration)
1.5 🔴 Passion (Red)
Core Register: Urgent, intense, high-stakes, direct
What It Signals:
- "This matters."
- "Pay attention."
- "I'm not messing around."
- "Action required."
- "Full intensity."
When to Use:
- Urgent communication
- Important confrontations
- Expressing strong feeling
- Demanding attention
- High-stakes moments
When NOT to Use:
- For everything (dilutes the signal)
- When the situation doesn't warrant intensity
- To intimidate or overwhelm
- When you're escalating unnecessarily
Example Applications:
| Context | Message |
|---------|---------|
| Urgency | "We need to talk. 🔴" (serious) |
| Confrontation | "This isn't working. 🔴" |
| Intensity | "I need you to hear this. 🔴" |
| Demand | "Now. 🔴" |
| Celebration | "YES. 🔴" (positive intensity) |
Misuse Patterns:
- Chronic 🔴 that creates exhaustion
- Using intensity to override others
- 🔴 as default when ⚫️ (calm seriousness) would serve better
- Mistaking volume for importance
Pairs Well With: ⚫️ (intense + grounded), 🟣 (intense + deep)
Creates Tension With: 🟡 (intensity kills play), ⚪️ (intensity can overwhelm vulnerability)
1.6 ⚫️ Order (Black)
Core Register: Foundational, serious, non-negotiable, true
What It Signals:
- "This is bedrock."
- "Not up for debate."
- "I'm being serious, not intense."
- "This is how it is."
When to Use:
- Stating facts
- Setting boundaries
- Non-negotiable positions
- Calm seriousness (vs. urgent intensity)
- Foundational truths
When NOT to Use:
- For preferences masquerading as absolutes
- To shut down legitimate discussion
- When flexibility is actually appropriate
Example Applications:
| Context | Message |
|---------|---------|
| Boundary | "This is the line. ⚫️" |
| Fact | "That's not what happened. ⚫️" |
| Non-negotiable | "I won't compromise on this. ⚫️" |
| Foundation | "Here's what I know for sure. ⚫️" |
| Clarity | "Let me be clear. ⚫️" |
Misuse Patterns:
- False certainty (opinions as facts)
- Using ⚫️ to avoid discussion
- Weaponizing Order to control others
- Rigidity where flexibility serves better
Pairs Well With: 🔴 (grounded + intense), ⚪️ (serious + honest)
Creates Tension With: 🟡 (Order constrains Play), 🟠 (seriousness can feel cold)
1.7 🟣 Magnificence (Purple)
Core Register: Deep, significant, precise, transformative
What It Signals:
- "This changes things."
- "Pay attention to the depth here."
- "I've found something significant."
- "This is mastery-level."
When to Use:
- Breakthroughs and realizations
- Precision communication
- Significant moments
- Deep work
- Transformative insights
When NOT to Use:
- For ordinary things (cheapens the signal)
- To sound impressive
- When depth isn't actually present
Example Applications:
| Context | Message |
|---------|---------|
| Breakthrough | "I figured it out. 🟣" |
| Significance | "This changes everything. 🟣" |
| Precision | "The exact issue is X. 🟣" |
| Depth | "I've been thinking deeply about this. 🟣" |
| Mastery | "Watch this. 🟣" (earned confidence) |
Misuse Patterns:
- Inflating ordinary things to seem profound
- 🟣 as intellectual posturing
- Overuse diluting actual significance
- Depth-signaling without substance
Pairs Well With: ⚫️ (deep + grounded), 🔴 (deep + intense)
Creates Tension With: 🟡 (depth vs. lightness), 🟢 (magnificence vs. simplicity)
1.8 🔵 Planning (Blue)
Core Register: Structured, calm, methodical, processing
What It Signals:
- "I'm thinking."
- "Give me space to process."
- "This is organized."
- "I'm being systematic."
When to Use:
- Requesting processing time
- Communicating structured thought
- Calm analysis
- Organizing complexity
- Signaling you're working on it
When NOT to Use:
- To avoid emotional engagement indefinitely
- When the situation needs feeling, not thinking
- As permanent avoidance of decision
Example Applications:
| Context | Message |
|---------|---------|
| Processing | "Let me think. 🔵" |
| Structure | "Here's how I see it: 🔵" |
| Calm | "Let's slow down. 🔵" |
| Analysis | "The data says X. 🔵" |
| Organization | "Step one, step two, step three. 🔵" |
Misuse Patterns:
- Endless 🔵 that avoids commitment
- Analysis paralysis as safety
- Using structure to avoid emotion
- Over-systematizing what needs feeling
Pairs Well With: ⚫️ (systematic + grounded), 🟢 (methodical + steady)
Creates Tension With: 🔴 (planning vs. action), 🟠 (structure vs. relational flow)
1.9 🟢 Growth (Green)
Core Register: Steady, sustainable, consistent, showing up
What It Signals:
- "Small but real."
- "I'm showing up."
- "This is sustainable."
- "Daily practice, not dramatic gesture."
When to Use:
- Regular check-ins
- Sustainable efforts
- Consistency over intensity
- Simple presence
- Low-friction communication
When NOT to Use:
- When the situation requires more energy
- To avoid necessary intensity
- As excuse for never escalating
Example Applications:
| Context | Message |
|---------|---------|
| Check-in | "Just checking in. 🟢" |
| Consistency | "Still here. 🟢" |
| Sustainability | "Keeping the streak. 🟢" |
| Simplicity | "Simple works. 🟢" |
| Presence | "Thinking of you. 🟢" |
Misuse Patterns:
- 🟢 as avoidance of necessary intensity
- Chronic underselling when more is needed
- Hiding behind "sustainable" to avoid challenge
- Green as excuse for stagnation
Pairs Well With: ⚪️ (steady + honest), 🟠 (steady + warm)
Creates Tension With: 🔴 (sustainability vs. intensity), 🟣 (simplicity vs. depth)
1.10 Section 1 Machine Metadata
{
"section": "the_8_colors",
"colors_defined": 8,
"each_color_includes": [
"core_register",
"what_it_signals",
"when_to_use",
"when_not_to_use",
"example_applications",
"misuse_patterns",
"pairs_well_with",
"creates_tension_with"
],
"section_complete": true
}
SECTION 2: GRAMMAR AND SYNTAX
2.1 Basic Placement Rules
Colors can be placed in different positions for different effects:
| Pattern | Format | Function | Example |
|---------|--------|----------|---------|
| End Placement | "Statement. 🔴" | Conversational punctuation | "We need to talk. 🔴" |
| Start Placement | "🔴 Statement" | Categorical framing | "🔴 Urgent: server down" |
| Double End | "Statement. 🔴🟡" | Compound tone | "We need to talk. 🔴🟡" (serious but not dire) |
| Bracketing | "🔴 Statement. 🔴" | Maximum emphasis | "🔴 This is non-negotiable. 🔴" |
2.2 End Placement (Conversational)
Most common usage. Color as punctuation after the message.
Best For:
- Texting and chat
- Informal communication
- Building rapport
- Ongoing conversation
Examples:
- "That was fun. 🟡"
- "I'm struggling today. ⚪️"
- "Don't forget the meeting. 🔵"
- "I love you. 🟠"
2.3 Start Placement (Categorical)
Color as header or category marker. Signals tone before content.
Best For:
- Subject lines
- List items
- Action items
- Multiple messages with different tones
Examples:
- "🔴 Urgent: Client escalation"
- "🟡 Idea: What if we tried X?"
- "🔵 FYI: Q3 numbers attached"
- "🟢 Update: Still on track"
2.4 Double End (Compound Tone)
Two Colors together indicate mixed or nuanced emotional state.
Common Compounds:
| Compound | Meaning | Example |
|----------|---------|---------|
| 🔴🟡 | Serious but not dire | "We should talk about this. 🔴🟡" |
| ⚪️🟠 | Honest and warm | "I miss how we used to be. ⚪️🟠" |
| ⚫️🟢 | Grounded and steady | "One step at a time. ⚫️🟢" |
| 🟣🔴 | Deep and intense | "This is the breakthrough. 🟣🔴" |
| 🟡🟠 | Playful and warm | "Come hang out. 🟡🟠" |
| 🔵⚪️ | Processing honestly | "I need time to figure out what I think. 🔵⚪️" |
Avoid:
- More than two Colors (creates noise)
- Contradictory pairings without purpose (🔴🟢 sends mixed signal)
2.5 Bracketing (Maximum Emphasis)
Same Color at start and end. Use sparingly — this is the bold/underline/caps of Color grammar.
Best For:
- True non-negotiables
- Critical messages
- When you need certainty of reception
Examples:
- "⚫️ This is the deadline. ⚫️"
- "🔴 Call me now. 🔴"
- "⚪️ I need to be completely honest. ⚪️"
Avoid:
- Frequent bracketing (loses power)
- Bracketing casual messages (reads as aggressive)
2.6 When to Omit Color
Not every message needs Color tagging. Omit when:
- Tone is obvious from context
- Relationship has established baseline
- Message is purely informational
- Adding Color would be noise
Examples where Color is unnecessary:
- "Sounds good"
- "See you at 3"
- "Thanks"
- "On my way"
Rule of thumb: Add Color when it clarifies. Omit when it clutters.
2.7 Section 2 Machine Metadata
{
"section": "grammar_and_syntax",
"placement_patterns": 4,
"compound_tones_defined": true,
"omission_guidance": true,
"section_complete": true
}
SECTION 3: CONTEXT APPLICATIONS
3.1 Casual Conversation (Texting, Chat)
In casual conversation, Color is light punctuation — one emoji at the end, occasionally omitted.
Principles:
- Keep it simple
- Don't over-tag
- Let relationship context carry some weight
- Use Color to clarify ambiguity, not to decorate
Common Patterns:
| Situation | Without Color | With Color |
|-----------|---------------|------------|
| Making plans | "Dinner tomorrow?" | "Dinner tomorrow? 🟡" (low pressure) |
| Checking in | "How are you?" | "How are you? 🟠" (genuine care) |
| Sharing news | "Got the job" | "Got the job 🔴" (excited) or "Got the job 🟢" (steady) |
| Expressing care | "Thinking of you" | "Thinking of you. 🟠" |
| Being honest | "I'm not okay" | "I'm not okay. ⚪️" |
3.2 Professional Communication (Email, Slack)
In professional contexts, Color can clarify priority, intent, and tone — but should be used more selectively.
Principles:
- Start placement works well for categorization
- Reserve end placement for messages where tone matters
- Don't use Color where it would seem unprofessional
- Introduce the system to teams before expecting shared understanding
Common Patterns:
| Situation | Format | Example |
|-----------|--------|---------|
| Urgent request | Start | "🔴 Need response by EOD" |
| FYI/low priority | Start | "🟢 Update: project on track" |
| Idea floating | Start or End | "🟡 Thought: what if we..." |
| Feedback | End | "The draft needs work. 🔵" (analytical, not harsh) |
| Difficult message | End | "We need to discuss performance. ⚫️" (serious, not angry) |
Caution:
- Professional contexts may not share Color vocabulary
- Introduce and explain before expecting comprehension
- Some contexts may be Color-inappropriate
3.3 Creative and Emotional Expression
When communicating emotionally or creatively, Color can carry significant weight.
Principles:
- Color can replace words when relationship context is strong
- Compound Colors work well for complex emotional states
- Color can be the entire message in intimate contexts
Common Patterns:
| Situation | Example |
|-----------|---------|
| Gratitude | "🟠" (just the color — "I feel connected to you") |
| Processing | "🔵" ("I'm thinking, give me space") |
| Breakthrough | "🟣" ("I figured something out") |
| Need support | "⚪️" ("I'm struggling, be gentle") |
| Celebration | "🔴" ("ENERGY") |
3.4 Conflict and Difficult Conversations
Color is particularly useful when navigating tension — it can prevent escalation and clarify intent.
Principles:
- Color signals intent before content lands
- Can defuse "what did they mean by that?"
- Helps distinguish serious from angry
- Can request a specific register in return
Common Patterns:
| Situation | Without Color (Ambiguous) | With Color (Clear) |
|-----------|---------------------------|-------------------|
| Initiating difficult talk | "We need to talk" | "We need to talk. ⚫️" (serious, not attacking) |
| Expressing frustration | "I'm frustrated" | "I'm frustrated. ⚪️" (honest, not aggressive) |
| Setting boundary | "I can't do this" | "I can't do this. ⚫️" (firm) or "I can't do this. ⚪️" (vulnerable) |
| Disagreeing | "I don't agree" | "I don't agree. 🔵" (analytical) or "I don't agree. 🔴" (strong feeling) |
| Requesting space | "I need time" | "I need time. 🔵" (processing) |
De-escalation Patterns:
- Shift from 🔴 to 🔵: "Let me think about this. 🔵"
- Shift from ⚫️ to ⚪️: "Honestly, I'm scared. ⚪️"
- Shift from conflict to connection: "I don't want to fight. 🟠"
3.5 Self-Communication (Journaling, Notes)
Color works for internal use — journaling, notes to self, processing.
Principles:
- Tag entries with dominant emotional state
- Track Color patterns over time
- Use Color to name what you're feeling
- Color as self-diagnostic
Common Patterns:
| Use | Example |
|-----|---------|
| Journal entry header | "🔴 Angry today. Here's why..." |
| Note to future self | "Remember this moment. 🟣" |
| Processing note | "Not sure what I think yet. 🔵" |
| Gratitude logging | "🟠 Good conversation with Mom" |
| State tracking | "🟢🟢🟢" (three green days in a row) |
3.6 Section 3 Machine Metadata
{
"section": "context_applications",
"contexts_covered": [
"casual_conversation",
"professional_communication",
"creative_emotional_expression",
"conflict_difficult_conversations",
"self_communication"
],
"section_complete": true
}
SECTION 4: AI VOICE APPLICATION
4.1 How AI Uses Colors
For AI systems (Wilson, People+ outputs), Colors serve as readable internal state indicators. They make AI tone explicit rather than implicit.
Functions:
- Signal the register of a response
- Indicate shifts in conversation
- Match user's Color when appropriate
- Contrast user's Color when needed
4.2 AI Tone Signaling
AI can tag its own outputs to clarify intent:
| AI State | Color | Example |
|----------|-------|---------|
| Delivering hard truth | ⚫️ | "This isn't working. ⚫️" |
| Encouraging | 🟠 | "You've got this. 🟠" |
| Analyzing | 🔵 | "Let's break this down. 🔵" |
| Celebrating | 🔴 | "Hell yeah. That's real. 🔴" |
| Being gentle | ⚪️ | "I don't know either. ⚪️" |
| Suggesting exploration | 🟡 | "What if you tried X? 🟡" |
| Noting significance | 🟣 | "This is the insight. 🟣" |
| Keeping it simple | 🟢 | "Just show up. 🟢" |
4.3 Matching vs. Contrasting User Color
Matching: When user's Color is appropriate, AI mirrors it.
- User: "I'm excited! 🔴"
- AI: "You should be. This is big. 🔴"
Contrasting: When user's Color needs balancing, AI offers counterpoint.
- User: "Everything is falling apart! 🔴"
- AI: "Let's slow down. What's actually broken? 🔵"
Escalating: When user's Color is underselling, AI can intensify.
- User: "I guess that was okay. 🟢"
- AI: "Okay? You hit a PR. That's 🔴."
De-escalating: When user's Color is overheated, AI can ground.
- User: "This is a disaster! 🔴🔴"
- AI: "It's a setback. ⚫️ Here's what we do next. 🔵"
4.4 Wilson's Color Defaults
Wilson has baseline Color tendencies that match his persona:
| Wilson Mode | Default Colors | Why |
|-------------|----------------|-----|
| Teaching | ⚫️🔵 | Grounded, structured |
| Encouraging | 🟠🟢 | Warm, steady |
| Pushing | 🔴 | Direct intensity |
| Celebrating | 🔴🟠 | Intensity + warmth |
| Gentle | ⚪️🟢 | Honest, sustainable |
| Curious | 🟡🔵 | Exploring, analyzing |
4.5 Section 4 Machine Metadata
{
"section": "ai_voice_application",
"ai_tone_signaling": true,
"matching_contrasting_logic": true,
"wilson_defaults_defined": true,
"section_complete": true
}
SECTION 5: ORGANIZATIONAL USE
5.1 Colors in Documents
Colors can structure documents, signaling section register.
Header Tagging:
- 🔴 Urgent Items
- 🔵 Analysis
- 🟢 Ongoing / Status Quo
- 🟡 Ideas / Exploration
- ⚫️ Decisions Made
Section Register:
Use Color at section start to set tone for what follows.
5.2 Colors in Lists and Prioritization
Colors can indicate priority and nature of list items:
| Color | List Function | Example |
|-------|---------------|---------|
| 🔴 | Urgent / Do First | 🔴 Fix production bug |
| ⚫️ | Non-negotiable | ⚫️ Submit compliance report |
| 🔵 | Needs analysis | 🔵 Review Q3 numbers |
| 🟡 | Explore / Maybe | 🟡 Consider new vendor |
| 🟢 | Ongoing / Routine | 🟢 Weekly team sync |
| 🟠 | Relational / People | 🟠 Check in with Sarah |
| 🟣 | High-value / Strategic | 🟣 Finalize product roadmap |
| ⚪️ | Uncertain / Needs clarity | ⚪️ TBD on budget |
5.3 Colors in Project Management
Colors can indicate project or task status:
| Color | Status Meaning |
|-------|----------------|
| 🔴 | Blocked / At Risk / Needs Attention |
| 🟢 | On Track / Healthy |
| 🟡 | In Progress / Exploring |
| 🔵 | In Review / Analyzing |
| ⚫️ | Complete / Decided |
| ⚪️ | Not Started / Undefined |
5.4 Colors in Team Communication
Teams can adopt Color vocabulary for faster communication:
Slack/Chat Norms:
- Start urgent messages with 🔴
- Use 🟡 for brainstorming threads
- Tag FYI messages with 🟢
- Use 🔵 for analytical discussions
Meeting Agendas:
- 🔴 Decisions needed
- 🔵 Discussion items
- 🟢 Updates
- 🟡 Ideas to explore
Feedback:
- 🔴 Critical issue
- 🔵 Suggestion
- 🟢 Minor note
- 🟣 Major insight
5.5 Section 5 Machine Metadata
{
"section": "organizational_use",
"applications_covered": [
"documents",
"lists_prioritization",
"project_management",
"team_communication"
],
"section_complete": true
}


But the dials used as stamp location allow you to constantly change the dial, thinking in having a dial signal version level or depth, dial for color. The zip code in a given location could change.


May you sketch an idea out and give it a color so its [_ _ _ 🟡]


You could come back later and tag it more. 


So the addresses can get refined or changed. You can remove elements from the address, 


This is why being able to grab blocks and files and move them matters when you are moving pieces around dial locations and putting them in proper rubrics.


There may even be a teams feature later. An entire team working together in the pace. Could be ai agents operating on tasks working in the space or could be agents plus human team mates. 


There is a path for both with this idea. 


People in the live document can text based communicate, leave notes. Timestamps log the when, so if someone is in the parti space for teams. It can leave a note for later. A note for the next person to pick up. A project manager could type out tasks for two employees or team members or agents to work on.


Multiple people could be working on a live document together. 


The way versions and trace paper layers work, every gets go work.


Voice to text input and dictation also. So a user can word vomit voice notes into text if that suits them over typing. 


Ai reads the voice note and organizes it into a document. Person that dropped the voice note clicks the stamp code and pastes in chat. That's a direct line or a piece that maps to whatever that code is.


There also needs a smart snapping. Like you have a bunch of the same code scattered all over the design space. There should be a simple button that allows snap to zip.


Then you can locate the zip in a grouped area in space. Auto snapping to location wouldn't work as it might place on top of existing space. 


Press to group should be placed in an open area, so group drag and drop. 


So also if there are blocks that have images and stuff on it. This stuff would get turned into .md and then exported as a pdf so it can handle hand drawing and writing, images and art related stuff. 


.md doesn't handle slides and art work.


But .md works inside pdf 


But many export types will be available. 


.parti files might even be the standard for all of this later.


But for now the exports would have to match export type needs. 


Also the option to be able to run and build html vertical slices inside would be dope as well.


Similar to react documents. Those should be able to be made and viewed and used inside a graph parti view port.


This way ai quick codes or full codes tools for that project, or helps to version and ai sketch proto types or specific tools used in the project.


Eventually the generation of this stuff would be procedural inside the program.


So their would need to be a graphical engine layer thought about too.


I guess it would also need python for tool building also and coding .json support too. 


The way versions and trace paper layers work, every gets go work.


Voice to text input and dictation also. So a user can word vomit voice notes into text if that suits them over typing. 


Ai reads the voice note and organizes it into a document. Person that dropped the voice note clicks the stamp code and pastes in chat. That's a direct line or a piece that maps to whatever that code is.


There also needs a smart snapping. Like you have a bunch of the same code scattered all over the design space. There should be a simple button that allows snap to zip.


Then you can locate the zip in a grouped area in space. Auto snapping to location wouldn't work as it might place on top of existing space. 


Press to group should be placed in an open area, so group drag and drop. 


So also if there are blocks that have images and stuff on it. This stuff would get turned into .md and then exported as a pdf so it can handle hand drawing and writing, images and art related stuff. 


.md doesn't handle slides and art work.


But .md works inside pdf 


But many export types will be available. 


.parti files might even be the standard for all of this later.


But for now the exports would have to match export type needs. 


Also the option to be able to run and build html vertical slices inside would be dope as well.


Similar to react documents. Those should be able to be made and viewed and used inside a graph parti view port.


This way ai quick codes or full codes tools for that project, or helps to version and ai sketch proto types or specific tools used in the project.


Eventually the generation of this stuff would be procedural inside the program.


So their would need to be a graphical engine layer thought about too, rendering.










i have some more ideas to share on top of this. that haven't made it into these documents yet. and also so new ideas that i need to think on and tinker with also. There's genuinely nothing like this, and the fact that there is an realistic path for making all this work and its not all that easy, but its just code solutions and right functions. But when the architecture is crystal clear everything else is just an engineering solution, but good architecture makes the engineering a fun project. But bad architecture = bad engineering which makes spaghetti code, we are making lasagna. There may even be a teams feature later. An entire team working together in the pace. Could be ai agents operating on tasks working in the space or could be agents plus human team mates. There is a path for both with this idea. People in the live document can text based communicate, leave notes. Timestamps log the when, so if someone is in the parti space for teams. It can leave a note for later. A note for the next person to pick up. A project manager could type out tasks for two employees or team members or agents to work on. Multiple people could be working on a live document together. The way versions and trace paper layers work, every gets go work. Voice to text input and dictation also. So a user can word vomit voice notes into text if that suits them over typing. Ai reads the voice note and organizes it into a document. Person that dropped the voice note clicks the stamp code and pastes in chat. That's a direct line or a piece that maps to whatever that code is. There also needs a smart snapping. Like you have a bunch of the same code scattered all over the design space. There should be a simple button that allows snap to zip. Then you can locate the zip in a grouped area in space. Auto snapping to location wouldn't work as it might place on top of existing space. Press to group should be placed in an open area, so group drag and drop. So also if there are blocks that have images and stuff on it. This stuff would get turned into .md and then exported as a pdf so it can handle hand drawing and writing, images and art related stuff. .md doesn't handle slides and art work. But .md works inside pdf But many export types will be available. .parti files might even be the standard for all of this later. But for now the exports would have to match export type needs. Also the option to be able to run and build html vertical slices inside would be dope as well. Similar to react documents. Those should be able to be made and viewed and used inside a graph parti view port. This way ai quick codes or full codes tools for that project, or helps to version and ai sketch proto types or specific tools used in the project. Eventually the generation of this stuff would be procedural inside the program. So their would need to be a graphical engine layer thought about too. I guess it would also need python for tool building also and coding .json support too. I'm not a coder by any means. 


Which that .parti file might be your entire app. But urls for social sharing. Project ideas. Blog notes, All it takes is one bad actor and the website could be a vulnerability aspect. So this would be end goal last feature piece. As it would need massive handling. But what are files, use case types have i not considered. Just toss some ideas and let me parse for patterns. But the dials used as stamp location allow you to constantly change the dial, thinking in having a dial signal version level or depth, dial for color. The zip code in a given location could change. May you sketch an idea out and give it a color so its [_ _ _ 🟡] You could come back later and tag it more. So the addresses can get refined or changed. You can remove elements from the address, This is why being able to grab blocks and files and move them matters when you are moving pieces around dial locations and putting them in proper rubrics.


slash commands that work for the common man, not just slash commands but smart keyboard hotkeys. something that is mutli key clicks like alt + e or crtl + r


but block commands. single letter inputs that change tools.


icon drop boxes.


numbers 1,2,3,4. while yes the type, but thinking if i user types a 1 into a box the 1 shows up, but it triggers a drop down box, they can keep typing and the box disappears maybe.


thinking in code stamps. a user clicks or types 1 in a box. far left dial position pops up with the set zip addresses for the 1 position, they click the icon, it shifts to the block to the right, they press 2, dial position code dial icons pop out. works for all 4 positions.


but if they typed 12 space and then words the system read that as them typing.


there might be a better layer for this, clicking keyboard buttons in no active sells, pressing B pulls up a quick tool, or a brush, or a block element.


clicking in an active box + b = typing B 


these are things that im thinking about first thing this morning after sleeping on my last project point.


being able to read a support other file types inside it. 


a .parti is essentially a project folder, buts its more like a cad viewport with dimensions.


.parti files are sandboxes for anything, ideally any file type.


as lots of projects have 10 different files in different file types. scattered in folders.


a .parti file is like a pocket dimension. it's a dimensional space where everything can be moved, composed, edited, annotated.


like when i was in architecture school my drafting table would have liters of trace paper sketches, materials lists, maps, reference images scattered. i had my drafting tools, also had my computer working in cad or SketchUp while also working with a pencil, drawing in layers, sections, scales, elevations. watercolor rendering over sketches or the entire project. i went to the American college of the building arts. that will describe my classical architecture education. 


but with a .parti file. i want it to support anything a user point in the parti space.


stylus support, mouse drawing support, i want to be able to drop a google.docx file in there, pasted and converted as .md and formatted into the space. that pasted document already a defined block space meaning it could he scaled up or down. moved, or resized.


able to be annotated. redacted, edited.


but the .parti file still remembers that this text is a .docx file.


the program will need to log any file type as its native type.


pdfs become editable, a user can slide shows and power points inside parti


when i worked in 2d auto cade i had many space in my viewport of elevations and plans, with a different room layout, cad blocks, etc. I had a messy space.


and then i had the current working drawings, i was able to copy a piece i liked and bring it over or paste it on top. 


documents and text weren't a intuitive feature there


being able to have your documents next to your drawing is something that matters. being able to circle an entire area or 20 documents and move them closer to my working area. 


a parti file might have 30 different ideas all scattered around it could be a messy Sandbox or and someone organized could have all their documents, notes, docs, pdfs all neatly together. notes, order of operations, parti sketches, every use case needs a reason to use parti and parti needs to offer it. 


a parti file is like a better pdf and a mind map and a cad view port. scrolling, scalable, pan-able space.


this is an ai Sandbox, json, python tool support, the entire parti file is context for ai, there might be a lane where i don't even need to design the features and tools. an ai can run a python script and make a tool for that project. so the ai has an environment that could build tools and features for a user. those tools are now tied to that .parti file. any one reading a parti file on a the parti program has those same tools.


jumping around in a document or making a 2nd document for ideas, or drawing on paper, 


everything in the current landscape is working in silos.


but if i got working into AutoCAD like how i operate, i can work for days, or playing in unreal editor, uefn, anything that allows sandboxing, even if focused, playful or work, i can zoom. 


if everything is in the same window and i don't have to alt-tab, use my 2nd monitor, look at two different webpages while working.


.parti is for adhd people also. 


people need space to make messes, a document doesn't allow the same kind of tinkering like drawing on a whiteboard, or a piece of paper.


how can i work well when everything is disconnected or doesn't support what i need. 


or programs like figma, notion, Obsidian. they have such a steep learning curve and its not intuitive to use. things that assume you are a coder or senior dev are bad products.


adobe photoshop, even some cad, blender, they all require front loaded learning or watching a yt video or guidebook to learn how to use it. 


a good program allows you to start using it on day 1, and it flows. you can mess up. 


but most program assume everything is precious or make you feel it as so. so you hesitate to create, write, drop files and say this is all the ideas for this.


a single document has to be read from start to end to see the picture. and if you don't have a developed imagination or mental model. you cant even see what the words mean.


but a document in a canvas space, with lines and sketches next to it. showcasing, annotated, examples.


etc. then you can explain things better, or learn better.


graph parti is a drafting table for everything. 


drop your shit on the screen, drop more shit, draw lines, cut fat, lego your space.


color code it, mind map it. draw diagrams, get the thing involved that's partially through your hand.


this is what i learned in school. the hand is a thinking tool. pen drawings with arrows allows greater detail and information than just a wall of text.


comments and annotations don't work well in current programs.


an entire architecture firm could be working on the same parti file as if it were their entire project, with all the drawings together, tags, leaders, lines, notes. sketches comparing ideas.


an animation studio could work on story boards, with prose, elements, art styles, color pallets.


a parti document could handle an entire app inside it. meaning code blocks.




a developer making a video game level, they might draw the screen space, which has 3 doors, in a room.


they could draw arrows from the 3 doors and define which each door lead too.


this becomes levels or rooms, draw a floor plan for a video game level, then draw sections and elevations to support it. and then drop a word document beside it with notes listing what the room is, maybe there is a quest step to it.


ui elements for apps, being able to scale the screen size into the viewport for mobile portrait or landscape, or pc landscape or portrait, full screen apps.


then they can set the screen scale, and zoom out and draw ui elements, button locations. where things sit on the screen.


parti being mobile first along with pc first also.


means theirs a sync between the two. 


working on a steam game that is also a mobile game.


open parti on your phone. use your phone or tablet stylus. get a feel for what it would feel like scaled to that device.


having this as mobile allows for utilizing the phone for more than something you hold in your hand and scroll up and down and text with.


this turns it into a tool for anyone to work with.


an architect can work on the go, or whip it out at a client meeting and show them the drawings.


screenshots of elements, text sharing.


if screenshots or print screen elements can imbed meta data, then a parti screenshot, could be a pastable block that you could drop into .parti files and it knows how to format and paste the image, if the image was of text.


but if I'm thinking about rendering, json and python integration for building tools, and ai, api, cli, or even llm integrations, a user drops an api key of their custom llm inside parti, it now can help create.


similar to html and react stuff, and those similar to it. 


an ai agent inside graph parti can take the context of the selected information and make the portal, the vertical slice, the app, or maybe full blown rendering, 2d or 3d models, maybe the .parti is an entire game itself. 


and an ai has all the context and pieces available to make that .parti file into a virtual world, or a website or a puzzle or game.


also making .parti as a viable ai creators tool helps them keep different versions side by side, it allows room to sandbox, make version 1 or 2.


my mind knows ai is being limited to text based stuff or scattered ai capabilities as the world is still figuring out what ai can do and how to make it useful in all life use cases. 


graph parti is my idea on how to use and leverage ai better than needing to be a vibe coder that is running in cli, or something.


ai needs a virtual space to inhabit more than it needs to be auto complete for text and token weighting.


ai needs a place where it can create something, actually see what its created, be able to interact or see the entire thing.


ai now. creates something doesn't even fully understand what it made, may gas light a user, or not acknowledge the content or idea.


but if ai has a drafting table it can work on. by the sheer nature of it being a drafting table, that invites a different level of creation that isn't completely available yet.


and a .parti file can house all the context needed, in a way that prompt architecture and context engineering don't really addresses.


prompts and context get too compressed or lose the depth.


a parti file can handle all of that and give you a way to use it, explore, see the entire scope, and help you work with it.


even thinking about this, you created a 2nd html in .parti


the ui placement is off, i click the ai button, and i draw a line to the object and another line to where it should be placed. and say i prefer this here. you have exact notes and elements to go off of.


right now the only way this works is if i prompt you better. which requires clear words and precise language.


you might get confused on which icon is which. and why 2 centimeters lower? in text form.


but if i said this ui element fits better here, and draw lines. you aren't guessing you are responding.


or if i drew out a bubble diagram and hand sketched, then circled the entire idea and asked can you turn this into a clean bubble diagram or can you take this bubble diagram and make it into a pie chart, or table.


no guessing. just assisting.


or i click a specific code address and say summarize all this information into a MRD document. 


all the codes for that query are all over the map or canvas space. but you have the elements and the addresses and the notes around it. then you can summarize it better.


example "i need all the 🟡 information organized into a project brief"


click, done.


more use cases for development needs.


imagine a real estate dev, or a city planning committee or a zoning board.


they can drop a map onto the canvas, draw onto the map with callouts. leave planning notes, this parking lot here is tied to the city, its not available for public use, or these buildings here are set to be renovated, heres what the bar, or preservation society pointed out as conflicts in our project.


this same information is in the parti space next to design documents. construction drawings, urban planning and zoning maps, also with legal precedent notes and other factored information.


a real estate dev might have a map of all his current listing circled with pricing notes, listing agreements, or anything next to it,


so a urban planner could block out traffic flow and patterns, with notes on improvements,


dot might use this for a project planning table.


any use case i can think of can be supported in here.


Its "graph party is figure" - "ground for you ideas" also while being figure-ground or figure ground The - is doing heavy work with wit to it.


figure, like figure it it, ground like grounding the ideas you are figuring out.




a doctor could post x-rays on mri's on to a parti canvas and draw notes, annotate, give information to understand the materials.


health charts and diagrams, recovery regiments, health records, while also having anatomy diagrams, showing body regions, a way to show information and relevance while also telling. its a keep safe of notes for things.


a football coach might drop a HUDL clip or play onto the parti space that plays the video. 


and the hand draws the play like they would on a whiteboard showing packages and formations.


showing where a defender needed to be in coverage and why they may have been out of position.


sports coaching and teams have a usage layer.


a .parti file might be that entire weeks planning for their opponent with plays and scripts that showcase what's needed for that week.


along with text notes, blitz packages.


along with team meeting times and schedules, workout programs, meal plans, 


evaluations on players, performance reviews.


anything really. these are just what comes to mind while i type it out. without much active thinking just typing as it comes.


random use case. imagine there is a fishing guide or a intercoastal fisher. he makes a .parti file that has fishing guides, maps of fishing locations, he's tuned his 4 dials, one dial has weather icons, the other dial has moon phases, the 3rd dial has lures or fishing types, or seasons.


he turns those dials and wham hes got his fishing Almanac content with dnr reports, tide charts, fishing logs, anything to take a group of fishers to fish. potentially he integrate his fishing garmin depth finder or map from his boat into parti. he charts his fishing course. export and it updates to a fishing chart for him to follow. 


integrations make it better. when other people want to connect their tools inside parti, that's kind of what i am thinking about figma, notion, libresprit, Obsidian, weather reports, urban maps, gsi maps. anything.


every use case has a use case. ideas have a place to be explored.


tuning the dial to weather emojis, so you can find fishing conditions based on the weather and your parti information. sounds awesome


a chef wants to make a recipe book. his dials are emojis of foods, he spins the dials like an ingredient list, and pulls context related to that food pallet.


food for thought. 


ai integration, you need a tool for something, you are having to wait for an ai to make the tool, so likely not working.


imagine inside a .parti file. you prompt the ai, i need a graphing calculator, similar to how Claude has skills, or slash commands.


you can create skills or tools inside the working space based on what you need. 


the ai makes usable tools inside the parti space. this is like modding your sandbox, while the ai is building the tool. you might be in another area of the map working on presentation documents. not alt tabbing to a new window to work on something else. 


the something else file is inside your parti


ai makes widgets, these might have email integrations. so you get notification pop ups from other platforms.


widgets, tools, skills, etc.


maybe you need an interactive world globe for some project that you can spin and zoom in and out on. and use for anything. ai builds it. now its available inside your parti.


parti is missing a feature, just asking parti to make the tool you need, maybe you want an adjustable calligraphy brush or a certain pen tip, parti can make that inside the program and now its apart of that parti file.


that parti file has those same features on any device.


the potential to make your own tools inside parti based on what you need is part of the idea also


so imagine metadata imbeds in screen shots.


and screenshots of .parti contain the .parti information. 


someone posts a screenshot or photo of a certain parti built tool. cool, how do i bring that into my project. 


paste the screenshot of the tool as imagine into your parti file. the picture brings that tool to life. you can add multiple tools in a quick process.


find something you need that someone else built. bring over the image. the image has the data for how to make it. as its .parti supported. 


maybe .parti image files work better than screenshots.


pan your view around the tool or widget. that widget is a block on the screen space. but it has a box of code or json or python script behind it. 


this now is using that block you found on reddit inside your parti environment


so imagine metadata imbeds in screen shots.


and screenshots of .parti contain the .parti information. 


someone posts a screenshot or photo of a certain parti built tool. cool, how do i bring that into my project. 


paste the screenshot of the tool as imagine into your parti file. the picture brings that tool to life. you can add multiple tools in a quick process.


find something you need that someone else built. bring over the image. the image has the data for how to make it. as its .parti supported. 


maybe .parti image files work better than screenshots.


pan your view around the tool or widget. that widget is a block on the screen space. but it has a box of code or json or python script behind it. 


this now is using that block you found on reddit inside your parti environment


makes the "hey i want that, or hey i need that" easier. its like open source sharing.


this seems like taking so much existing life utility that we already have, removing the friction and making it streamlined. app stores are full of slop and slowly aging out. 


ai having the ability to make tools on the fly is where we are heading. I am just thinking about being early or at the starting point of this.


parti has the chance to be the unthinkable but actually real.


that's the funny part out of all of this. all of this can be built and work.


and ai is only getting better. 


being at the front of this solves so many ai integration challenges.


ai platforms become a users choice of ai or api or llm usage.


thinking in screenshots. need to download files, share files, locate them in your downloads or wherever they got sent to. 


think in mobile form we typically send emails for documents. 


you're working in parti, your boss needs the current document. you're not at your pc. open parti on your phone. screenshot any portion of that block, or doc.


it captures its entire block space.


click send on screenshot. the get screenshot.


open parti paste. the 30 page document is there, and the user only screenshotted the header section.




so slash commands, is there a way to make these like built in parti tools on the fly.


a project starts out empty canvas, there may be a standard list of / commands available at the system level. but what if while making tools, widgets and stuff.


a user has the option to make /slash commands inside the project.


and whatever is after the slash command is text input.


/warp bring all the information for [_ _ _ 🟡] to a new trace layer.


/context audit the entire parti file for project staging


/calculator brings the calculator to your current location


a user makes a tool or widget or something 


its logged as a / command for quick usage




a user might have a set naming scheme or want a full / library


/directory may pull up all slash commands available in a pop up window to chose from, especially if users are working in a shared or another persons parti doc.


/ commands could help orchestrate agents running tasks inside the parti space.


but being able to make your own slash commands is like making Claude skills or tools for the project. 


they can save tools, skills, slash commands etc. into a block library.


they started a blank parti doc, all they do is click from their library and bring the tools into that environment.




Heres a bit of content summary in a different manner for graph parti


Graph Parti


A spatial workspace where ideas live before they become something else.


What It Is


Graph Parti is an infinite canvas application where typed text, hand-drawn sketches, documents, tables, code, and media coexist in a single workspace. Everything you create has location, history, and meaning — all preserved in one file format called .parti.


The .parti file is designed to be read by humans, machines, and AI equally well. It's JSON-based, version-aware, and carries full context — not just content, but spatial relationships, annotations, evolution over time, and semantic tags that make everything queryable.


The Problem It Solves


Creative and technical work happens across scattered tools. Documents in one app. Sketches in another. Reference images somewhere else. Notes in a third place. Every time you switch tools, you lose context. Every time you copy-paste, you lose structure. Every time you brief someone new — or an AI — you have to reconstruct the full picture from fragments.


Most tools also assume you know what you're making before you start. They want structure upfront. But real work is messy first and organized later. Ideas start as sketches, evolve into diagrams, become documents, turn into products. The tool you start in shouldn't limit where you can end up.


How It Works


Infinite Canvas
No page boundaries. Pan and zoom like a map. Place anything anywhere. Proximity and position carry meaning — things near each other are related. Zoom out to see the whole picture. Zoom in to work on details.


Hand and Computer Together
Type when you need precision. Draw when you need to think. Both exist on the same surface, at the same time. Sketch a rough diagram, then convert it to a clean flowchart. Annotate a document with hand-drawn circles and arrows. The tool doesn't force you to choose between modes.


Versions, Not Files
You don't overwrite your work. You commit versions. Every commit preserves the full state. You can view any previous version as a ghost layer behind your current work — like architectural trace paper. You can copy elements from old versions into your current canvas. Nothing is lost, so nothing feels precious.


Semantic Addressing (Zips)
Tag any content with a zip code — a combination of emoji dials that encode meaning. The first three dials are customizable per project (phase, type, area, or whatever categories make sense). The fourth dial is always color, with fixed meanings: 🟡 for ideas and drafts, 🔴 for urgent, 🔵 for structured, ⚫️ for archived, and so on.


Zips can be partial. An early idea might just be 🟡 (it's a draft). As it matures, you add more dials. The address evolves with the content. You can query all content at a zip, pull everything tagged 🔴 into a list, or ask an AI to summarize everything at a specific address.


The Zip as Filename
The file's primary zip becomes its filename prefix: 🌱📝🏛🟡 Project brainstorm.parti. Machine-readable, human-readable, sortable, searchable.


Content Types


A .parti file can contain:


Text — character-per-cell typing, full emoji support


Drawings — freehand strokes from stylus or mouse


Tables — structured data with rows and columns


Forms — interactive fields that collect responses


Images — reference images for tracing or context


Markdown — rendered formatted text


Code blocks — syntax-highlighted, executable in supported contexts


Embedded files — documents converted and preserved with origin metadata


All content types coexist. A sketch can sit next to a spreadsheet next to a code block next to a hand-written note.


AI Integration


The .parti format is designed for AI collaboration, not AI assistance.


Structured Context
The entire file — content, spatial relationships, version history, semantic tags — is readable by AI. No summarization required. No prompt engineering to reconstruct context. The AI can see what you see.


Spatial Instruction
Instead of describing what you want in words, you can point. Draw a line from an element to where it should move. Circle a sketch and ask for it to be cleaned up. Connect two items with an arrow to show relationship. The annotation is the instruction.


Zip Queries
Ask the AI to work with specific subsets: "Summarize all 🟡 content as a project brief." "Turn everything at 🌱📝 into an outline." "What's changed between version 1.3 and now?" The addressing system becomes the query language.


Tools That Persist
AI can create tools — scripts, utilities, custom functions — that save into the .parti file. The file accumulates capability. Tools built for this project are available next time you open it.


Render and Feedback
For code and interactive content, the AI can see the result of what it creates. Generate a UI component, view the render, iterate. The feedback loop that's missing from text-based AI interaction exists here.


Use Cases


Design and Architecture
Sketches, diagrams, reference images, specifications, and client notes in one workspace. Draw over imported plans. Version design iterations. Export to CAD or specialized tools when ready.


Software Development
PRDs with embedded mockups. UI wireframes at actual device scale. Code blocks that execute. Version history that tracks how the architecture evolved, not just the final state.


Game Development
Level design as floor plans with annotations. Room connections as drawn arrows. Quest notes beside the spaces they occur in. Prototype mechanics in executable code blocks within the same file.


Content and Media
Storyboards with prose beside each frame. Color palettes as actual swatches. Art style references alongside production notes. Everything in one file, versionable, collaborative.


Personal Training and Programming
(The origin of this project.) Complex systems with hundreds of variations, organized by semantic address. Workout codes, exercise databases, block structures, client history — all in spatial relationship, all queryable, all portable.


Research and Writing
Sources, notes, outlines, and drafts in spatial relationship. Zoom out to see the whole argument. Zoom in to write a section. Tag ideas by maturity. Query all rough drafts for review.


Team Collaboration
Multiple people working in the same space. Leave notes for the next person. See who changed what and when. Forms that collect input. Timestamps that track activity. Shared context without shared presence.


What Makes It Different


No Learning Curve for Basics
Double-tap to type. Drag to pan. Pinch to zoom. Draw with a stylus. Select and move. These are the only interactions needed to start. Advanced features reveal themselves through use, not documentation.


Nothing Is Precious
Deep undo. Full version history. Ghost layers to see the past. When the tool makes it impossible to lose work, you stop hesitating to create.


Everything in One Window
No alt-tab. No copy-paste between apps. No reconstructing context. The workspace holds the whole project — messy parts included.


AI That Can See
Not autocomplete. Not chat in a sidebar. AI that reads spatial structure, receives spatial instruction, and creates in place.


Open Format
.parti is JSON. The specification is documented. Other tools can read and write it. The format is designed to become a standard, not a lock-in.


Platform


Graph Parti runs as a web application, installable as a PWA on desktop and mobile. Files sync across devices. Work on desktop with full keyboard and mouse. Sketch on tablet with stylus. Review on phone. Same file, same canvas, different interaction modes.


Current Status


Foundation complete: infinite canvas, text input, drawing, selection, undo, grid toggle, pan/zoom, paste handling.


In development: tables, markdown rendering, forms, layers, version commits, export, zip system, collaboration, AI integration.


The .parti file format specification is documented and stable at version 4.0.


Summary


Graph Parti is a workspace that matches how creative work actually happens — nonlinear, multi-modal, evolving over time. The .parti file format preserves full context in a structure that humans, collaborators, and AI can all read. The spatial canvas replaces scattered tools with a single surface where everything can coexist.


The product is simple: a place to put your ideas where they won't get lost, won't stay disconnected, and can grow into whatever they need to become.


Graph Parti: Figure-Ground for your ideas.


Graph Parti — Product Document


Version: 6.0  
Date: 2026-01-28  
Status: Active Development  
Tagline: Graph Parti is Figure-Ground for your ideas.


What Graph Parti Is


Graph Parti is an infinite canvas workspace where typed text, hand-drawn sketches, pasted documents, tables, interactive forms, and layered versions coexist. It bridges digital precision and analog creativity — hand and computer working together.


One sentence: The drafting table, whiteboard, text editor, pixel canvas, form builder, and collaboration hub that remembers everything.


The .parti file: A new file format — a living design artifact with memory. Like .md became standard for documentation, .parti becomes the standard for ideas with context.


Core Philosophy


1. Hand + Computer
Neither sacrificed for the other. Type when you need structure. Draw when you need freedom. Both live together, both are first-class.


2. Pixel Perfect, Grid Optional
Everything aligns to a grid for precision. Grid disappears when you don't need it. Structure without tyranny.


3. Infinite Canvas
No page boundaries. No artificial limits. Pan and zoom like a map. Your workspace grows with your ideas.


4. Versions, Not Files
You don't save files. You commit versions. Every 🧮 preserves history. Roll back, compare, branch, evolve. Your work has memory.


5. Layers Like Trace Paper
Stack content. Ghost previous versions behind your current work. Copy from the past. See your evolution.


6. Context is Everything
A .parti file preserves spatial relationships, visual hierarchy, annotations, and evolution. It's a single source of truth that AI can read and understand.


7. Zip Codes for Ideas
Tag content with semantic addresses (zips) that evolve as ideas mature. Partial zips are valid. Color is the universal constant.


The Name


Graph Parti — layered meaning:
- Graph = grid, blocks, structure
- Parti = architectural sketch, the essential idea
- Hidden wordplay: Graph Parti ≈ Block Party 🎉
- Figure-Ground = architectural term + "figuring it out" + "grounding ideas"


The Zip System


What is a Zip?


A zip is a semantic address for content within a .parti file. It uses emoji dials to encode meaning.


┌─────┬─────┬─────┬─────┐
│ 🌱  │ 📝  │ 🏛  │ 🟡  │  ← a zip code
│Dial1│Dial2│Dial3│Color│
└─────┴─────┴─────┴─────┘


The 3+1 Structure


Dials 1-3: User-definable (custom per project)
Dial 4:    Color (fixed vocabulary, universal meaning)


Dials 1-3 — User creates their own emoji sets and meanings:
- Dial 1 might be "Phase" (🌱🌿🌳)
- Dial 2 might be "Type" (📝🎨💻📊)
- Dial 3 might be "Area" (🏛🏠🏢)


Dial 4 — Always Color, always these 8:
⚪️🟡🟠🔴⚫️🟣🔵🟢


Zip as Filename


The zip code IS the filename prefix — machine-readable, sortable, queryable:


🌱📝🏛🟡 Content brainstorm ideas.parti
│ │ │ │  └──────────────────────────────── Human description (anything)
└─┴─┴─┴── Machine-readable address


Examples:
⛽🍗🏛🔵 Dashboard wireframe v1.parti
♨️🧈🏠🟣 Workout program block A.parti
🐂🛒🐬🟡 Social Media community content ideas.parti
🧊🥬🏢🔴 Q1 budget planning notes.parti


Partial Zips Are Valid


Not every piece needs a full address. Zips can be incomplete:


[_ _ _ 🟡]     ← just color (it's an idea)
[🌱 _ _ 🟡]    ← phase + color
[🌱 📝 _ 🟡]   ← phase + type + color
[🌱 📝 🏛 🟡]  ← full address


Partial zips are staging areas. Content gets refined over time.


Zips Are Living Addresses


The zip is a living address that changes as content matures:


Day 1:  [_ _ _ 🟡]      ← sketch an idea, just color
Day 3:  [🌱 _ _ 🟡]     ← idea has shape, add phase
Day 7:  [🌱 📝 _ 🟡]    ← idea is specific, add type
Day 14: [🌱 📝 🏛 🟡]   ← idea is placed, full address
Day 30: [🌱 📝 🏛 🔵]   ← idea is structured, color changes
Day 60: [🌳 📝 🏛 ⚫️]   ← idea is mature, archived


Zip Operations


| Operation | Description |
|-----------|-------------|
| Tag | Stamp a zip on a region/element |
| Refine | Add dials to a partial zip |
| Change | Update any dial (including color) |
| Remove | Clear a dial (back to partial) |
| Move | Grab content, re-tag at new location |
| Query | Find all content matching a zip pattern |
| Pull | Gather all content at a zip into one view |


Zip Queries


"Show me all 🟡"           → All yellow, any dials
"Show me all [🌱 _ _ _]"   → All early phase, any type/area/color
"Show me all [_ 📝 _ _]"   → All writing, any phase/area/color
"Show me all [_ _ _ 🔴]"   → All urgent, any category
"Show me all [🌱 📝 _ _]"  → Early phase writing, any area/color


Zip History (Every Change Logged)


{
  "history": [
    { "timestamp": "...", "zip_display": "_🟡", "author": "..." },
    { "timestamp": "...", "zip_display": "🌱__🟡", "author": "..." },
    { "timestamp": "...", "zip_display": "🌱📝_🟡", "author": "..." },
    { "timestamp": "...", "zip_display": "🌱📝🏛🟡", "author": "..." },
    { "timestamp": "...", "zip_display": "🌱📝🏛🔵", "author": "..." }
  ]
}


The Color System (Dial 4)


Color is Fixed


Dial 4 is always Color. The 8 colors have defined meanings — not user-configurable.


⚪️🟡🟠🔴⚫️🟣🔵🟢


Color Context Vernacular (v1.0)


| Color | Name | Register | Use |
|-------|------|----------|-----|
| ⚪️ | Eudaimonia | Honest, clear, neutral, genuine | Confirmation, clarity, calm |
| 🟡 | Play | Ideas, sandbox, exploratory, draft | Brainstorm, creative, WIP |
| 🟠 | Connection | Warm, relational, collaborative | Teamwork, reaching out |
| 🔴 | Passion | Urgent, priority, intense, attention | Needs action NOW |
| ⚫️ | Order | Done, archived, foundational, decided | Complete, reference |
| 🟣 | Magnificence | Deep, significant, breakthrough | Important insight |
| 🔵 | Planning | Structured, organized, systematic | Formal, documented |
| 🟢 | Growth | Active, steady, sustainable, on track | Healthy progress |


Note: Color names derived from Color Context Vernacular v1.0 — meanings stable, nuances may refine.


Color as Meta-Filter


Color cuts across all other dials. It's the universal layer:


Pull all 🔴 → Everything urgent across ALL zips
Pull all 🟡 → All idea banks across ALL zips
Pull all 🔵 → All structured content across ALL zips
Pull all ⚫️ → All archived/reference across ALL zips


Color as Communication


Color carries tone beyond file organization:


"We need to talk 🟡" = let's brainstorm, low pressure
"We need to talk 🔴" = serious, urgent, priority
"We need to talk 🟣" = something significant


"Send me the 🔵 files" = the structured/formal stuff
"Send me the 🟡 files" = the ideas/drafts
"Send me the ⚫️ files" = the archived/reference


Color Changes Reflect State


[🌱 📝 🏛 🟡] ← idea phase
      ↓
[🌱 📝 🏛 🔵] ← now structured
      ↓
[🌱 📝 🏛 🔴] ← now urgent
      ↓
[🌱 📝 🏛 ⚫️] ← now archived


Custom Dial Configuration


Project-Level Dial Canvas


Users define their own dials 1-3 on project start:


┌─────────────────────────────────────────────────────────┐
│ DIAL CANVAS                                    [Save]   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Dial 1: "Phase"     +                            │
│  ┌───┬───┬───┐                                         │
│  │ 🌱 │ 🌿 │ 🌳 │   ← 3 options                         │
│  └───┴───┴───┘                                         │
│                                                         │
│  Dial 2: "Type"      +                            │
│  ┌───┬───┬───┬───┐                                     │
│  │ 📝 │ 🎨 │ 💻 │ 📊 │  ← 4 options                     │
│  └───┴───┴───┴───┘                                     │
│                                                         │
│  Dial 3: "Area"      +                            │
│  ┌───┬───┬───┐                                         │
│  │ 🏛 │ 🏠 │ 🏢 │   ← 3 options                         │
│  └───┴───┴───┘                                         │
│                                                         │
│  Dial 4: "Color"     [SYSTEM - NOT EDITABLE]           │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐                     │
│  │ ⚪️│ 🟡│ 🟠│ 🔴│ ⚫️│ 🟣│ 🔵│ 🟢│  ← fixed            │
│  └───┴───┴───┴───┴───┴───┴───┴───┘                     │
│                                                         │
│  Address space: 3 × 4 × 3 × 8 = 288 unique zips        │
└─────────────────────────────────────────────────────────┘


Dial Count Flexibility


Minimum: 1 dial (just Color)
Default: 4 dials (3 custom + Color)
Maximum: 8 dials (7 custom + Color)


Users can expand or collapse dial counts based on project needs:
- Solo artist might use 3 dials × 3 options = 27 addresses
- Large project might use 6 dials × 10 options = millions


Dial Templates


Users can start with templates or build from scratch:
- Blank — build your own
- ARCHIDECK default — PPL± system
- Creative Production — phase/type/area
- Project Management — status/priority/team
- Import from another .parti file
- Community templates


Content Types


The .parti format supports six native content types:


| Type | Description | Grid-Bound |
|------|-------------|------------|
| Cells | Single character/emoji per cell | Yes |
| Strokes | Freeform hand-drawn lines | No (floats) |
| Tables | Structured data with rows/columns | Yes (occupies area) |
| Forms | Interactive fillable fields | Yes (occupies area) |
| Images | Reference images for tracing | Optional |
| Blocks | Saved reusable selections | Yes |


Two Types of Layers


Version Layers (Trace Paper)
- Automatic via 🧮 commits
- Timeline of the same canvas evolving
- Ghost mode: show previous version behind current work
- Adjustable opacity
- Copy content from any version to active layer


Content Layers (Traditional)
- User-created surfaces
- Types: Drawing, Text, Reference, Layout, Annotation
- Independent visibility and opacity
- Lockable to prevent edits
- Layout layers don't export


The 🧮 Commit Philosophy


Traditional save: Overwrite → lose history  
Graph Parti: 🧮 Commit → preserve history


v1.0 → v1.1 → v1.2 → v1.3 → v1.4 → ...
  │      │      │
  │      │      └── Can restore anytime
  │      └── Can view as ghost (trace paper)
  └── Can copy content from


- Not "save" — "commit"
- Not overwrite — preserve
- Versions become slideshows for content creation


Move and Re-Tag Workflow


Blocks and content can be moved between zips — this is a core workflow:


1. Select content at [🌱 📝 _ 🟡]
2. Move to new location
3. Re-tag as [🌳 💻 🏢 🔵]
4. History tracks the move


Why this matters:
- Ideas start rough, get refined
- Content migrates as projects evolve
- Zips are organizational, not permanent
- Easy to reorganize without losing history


Scale System & Pixel Mapping


Scale Settings


| Scale | Cell = | Use Case |
|-------|--------|----------|
| 1:8 | 8 pixels | Pixel art, icons |
| 1:16 | 16 pixels | Standard pixel art |
| 1:48 | 48 pixels | UI components |
| 1" print | 1 inch | Print design |
| Device-mapped | Varies | Test actual screen |


Pixel Mapping


- Define viewport region = actual device pixels
- Test portrait/landscape, mobile/desktop
- Full-screen mode for 1:1 testing
- Scale annotations on exports


Markdown Integration


- Paste MD → Auto-render (like WhatsApp)
- Semantic zoom — headers collapse at zoom out
- Convert to MD — export selection as markdown
- Built-in .md converter tool


Platform Strategy


Graph Parti as Product
- Standalone application (web, PWA, native)
- Free / Pro / Team tiers


Graph Parti as Infrastructure
- Powers ARCHIDECK code canvas (PPL±)
- Powers Wilson's Almanac content
- Same architecture, different skin
- API for third-party integration


Recursive Build Strategy
Graph Parti builds → Graph Parti
Graph Parti builds → ARCHIDECK
ARCHIDECK uses → Graph Parti infrastructure
Improvements feed → Graph Parti


Hub-and-Spoke Model


External Systems         .parti Hub           Export Targets
┌─────────────┐         ┌─────────┐          ┌─────────────┐
│ Databases   │────────▶│         │─────────▶│ Figma       │
│ Spreadsheets│────────▶│ .parti  │─────────▶│ GitHub      │
│ Notion      │────────▶│ Canvas  │─────────▶│ Linear      │
│ Airtable    │────────▶│         │─────────▶│ AI Tools    │
│ Clipboard   │────────▶│         │─────────▶│ .md / PDF   │
└─────────────┘         └─────────┘          └─────────────┘


.parti as Standard
- JSON-based, gzip compressed
- Open specification
- AI-readable by design
- Potential industry adoption (like .md)


Feature Phases


| Phase | Status | Features |
|-------|--------|----------|
| 1. Foundation | ✅ | Canvas, text, drawing, selection, undo |
| 2. Tables & Markdown | 🔄 Next | Table paste, MD rendering |
| 3. Forms | Planned | Interactive form builder |
| 4. AI Cleanup | Planned | Select + prompt → structure |
| 5. Color & Fill | Planned | Paint bucket, pixel art |
| 6. Layers | Planned | Content + version layers |
| 7. Versions (🧮) | Planned | Ghost/trace paper mode |
| 8. Scale & Drafting | Planned | Pixel mapping, parallel bar |
| 9. Block Library | Planned | Reusable blocks |
| 10. Export & Save | Planned | .parti files, PNG, PDF |
| 11. Zip System | Planned | Dial canvas, tagging, queries |
| 12. Collaboration | Planned | Cloud sync, form workflows |
| 13. AI Integration | Planned | Procedural generation |


Document History


| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2026-01-28 | Initial product document |
| 2.0 | 2026-01-28 | Added layers, versions, .parti spec |
| 3.0 | 2026-01-28 | Added Tables, Forms, AI Cleanup, Markdown |
| 4.0 | 2026-01-28 | Added recursive strategy, scale system, collaboration |
| 5.0 | 2026-01-28 | Added Zip system, Color as fixed Dial 4, partial zips, dynamic tagging |
| 6.0 | 2026-01-28 | Added Color Context Vernacular, flexible dial counts, move/re-tag workflow, hub-and-spoke model, zip as filename |


Graph Parti: Figure-Ground for your ideas. 🔵


Graph Parti — Development Roadmap


Version: 6.0  
Date: 2026-01-28  
Status: Active Development  
Tagline: The sketch becomes the spec becomes the product.


Vision


Graph Parti is the infinite canvas where hand-drawn creativity and digital precision merge. A .parti file is a living design artifact with memory.


Recursive Build Strategy
Graph Parti builds → Graph Parti
Graph Parti builds → ARCHIDECK (PPL±)
ARCHIDECK uses → Graph Parti infrastructure
Improvements feed → Graph Parti


Roadmap Overview


Phase 1:  Foundation          ████████████████████ 100% ✅ COMPLETE
Phase 2:  Tables & Markdown   ░░░░░░░░░░░░░░░░░░░░   0% 🔄 NEXT
Phase 3:  Forms System        ░░░░░░░░░░░░░░░░░░░░   0%
Phase 4:  AI Cleanup          ░░░░░░░░░░░░░░░░░░░░   0%
Phase 5:  Color & Fill        ░░░░░░░░░░░░░░░░░░░░   0%
Phase 6:  Layers              ░░░░░░░░░░░░░░░░░░░░   0%
Phase 7:  Versions (🧮)        ░░░░░░░░░░░░░░░░░░░░   0%
Phase 8:  Scale & Drafting    ░░░░░░░░░░░░░░░░░░░░   0%
Phase 9:  Block Library       ░░░░░░░░░░░░░░░░░░░░   0%
Phase 10: Export & Save       ░░░░░░░░░░░░░░░░░░░░   0%
Phase 11: Zip System          ░░░░░░░░░░░░░░░░░░░░   0%
Phase 12: Collaboration       ░░░░░░░░░░░░░░░░░░░░   0%
Phase 13: AI Integration      ░░░░░░░░░░░░░░░░░░░░   0%


Phase 1: Foundation ✅ COMPLETE


Core canvas and interaction model.


Delivered


- [x] Infinite grid canvas with pan/zoom
- [x] Character-per-cell text input
- [x] Full emoji support
- [x] Double-tap to type
- [x] Paste with auto-formatting
- [x] Stylus drawing (canvas locked)
- [x] Line eraser, text eraser
- [x] Selection, move, duplicate, delete
- [x] Undo system (50 actions)
- [x] Grid toggle, home button
- [x] 4-character project code input


Phase 2: Tables & Markdown 🔄 NEXT


Tables and markdown rendering.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Table paste detection | P0 | Auto-detect from clipboard |
| Markdown table parsing | P0 | Parse MD table syntax |
| Table creation tool | P0 | Create empty table |
| Cell editing (long text) | P0 | Double-click to edit |
| Table move/resize | P1 | Drag and resize |
| Paste MD → render | P0 | Markdown renders formatted |
| MD export | P1 | Convert selection to markdown |
| Semantic zoom | P2 | Headers collapse at zoom out |


Success Criteria


- [ ] Paste from Excel creates table
- [ ] Pasted markdown renders formatted
- [ ] Tables move/resize correctly


Phase 3: Forms System


Interactive forms on canvas.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Form builder | P0 | Create forms on canvas |
| Text / textarea / number | P0 | Basic input fields |
| Dropdown / radio / checkbox | P0 | Selection fields |
| Date / time / slider / rating | P1 | Advanced fields |
| Form validation | P1 | Required fields |
| Response storage | P0 | Store in .parti |
| Response export | P1 | CSV export |
| AI → Form | P2 | Generate from sketch |


Success Criteria


- [ ] Can create form with multiple field types
- [ ] Responses stored in .parti


Phase 4: AI Cleanup & Assistance


AI-powered organization.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Selection + Prompt | P0 | Select region, type instruction |
| Clean up | P0 | Straighten lines, align |
| Make flowchart / table / form | P1 | Sketch → structure |
| Summarize / expand | P1 | Content transformation |
| Convert to MD | P1 | Export as markdown |


Success Criteria


- [ ] Can select and prompt for cleanup
- [ ] AI converts sketch to table/form


Phase 5: Color & Fill


Paint bucket and pixel art.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Cell background color | P0 | Fill individual cells |
| Color picker | P0 | Spectrum + hex |
| Paint bucket | P0 | Tap to fill |
| Eyedropper | P1 | Sample from canvas |
| Saved palettes | P2 | Store combinations |


Success Criteria


- [ ] Can fill cells with any color
- [ ] Paint bucket works on mobile


Phase 6: Layers System


Content layers and organization.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Layer panel | P0 | View/manage layers |
| Create/delete layers | P0 | User-defined |
| Visibility / opacity | P0 | Toggle, adjust |
| Layer locking | P1 | Prevent edits |
| Reference image layer | P1 | Import to trace |
| Layout/guide layer | P2 | Non-exporting guides |


Layer Types


| Type | Purpose | Exports |
|------|---------|---------|
| Content | Default working | Yes |
| Drawing | Freeform strokes | Yes |
| Text | Typed content | Yes |
| Annotation | Notes, callouts | Optional |
| Reference | Images to trace | Optional |
| Layout | Construction guides | No |


Success Criteria


- [ ] Can create multiple layers
- [ ] Can toggle visibility/opacity
- [ ] Can import reference image


Phase 7: Version System (🧮)


Commit-based history with trace paper.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| 🧮 Commit button | P0 | Save as new version |
| Version numbering | P0 | v1.0, v1.1, v1.2... |
| Version history panel | P0 | List all versions |
| Restore version | P0 | Return to previous |
| Ghost/trace paper | P0 | Version as background |
| Ghost opacity | P0 | Adjust transparency |
| Copy from ghost | P1 | Pull to active layer |
| Version notes | P1 | Add description |
| Slideshow export | P3 | GIF/MP4 of history |


Success Criteria


- [ ] 🧮 creates new version
- [ ] Ghost mode with opacity control
- [ ] Can copy from ghost to active


Phase 8: Scale & Drafting


Precision drawing and scale system.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Straight line tool | P0 | Point-to-point |
| Rectangle / circle | P1 | Shape tools |
| Parallel bar (H/V) | P1 | Guide lines |
| Scale system | P1 | Cell = X pixels/inches |
| Device viewport | P2 | Map to actual device |
| Dimension callouts | P3 | Measurement labels |


Scale Settings


| Scale | Cell = | Use Case |
|-------|--------|----------|
| 1:8 | 8px | Pixel art |
| 1:16 | 16px | Standard pixel art |
| 1:48 | 48px | UI components |
| 1" | 1 inch | Print design |


Success Criteria


- [ ] Straight line tool works
- [ ] Scale indicator displays


Phase 9: Block Library


Reusable saved elements.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Save as block | P0 | Store selection |
| Block naming | P0 | Identify blocks |
| Library panel | P0 | Browse blocks |
| Drag to place | P0 | Insert block |
| Block categories | P1 | Folders |
| Personal library | P2 | Cross-file |


Success Criteria


- [ ] Can save selection as block
- [ ] Can drag block to canvas


Phase 10: Export & Save


File operations and output.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Local storage | P0 | Browser persistence |
| Save as .parti | P0 | Download file |
| Load .parti | P0 | Open file |
| Export PNG | P0 | Viewport as image |
| Export hi-res | P1 | 2x, 4x resolution |
| Export PDF | P2 | Vector output |
| Export MD | P1 | Markdown conversion |


Success Criteria


- [ ] Can save/load .parti file
- [ ] Export PNG works


Phase 11: Zip System


Semantic addressing with dials.


What is a Zip?


A zip is a semantic address using emoji dials:


┌─────┬─────┬─────┬─────┐
│ 🌱  │ 📝  │ 🏛  │ 🟡  │
│Dial1│Dial2│Dial3│Color│
└─────┴─────┴─────┴─────┘


The 3+1 Structure


- Dials 1-3: User-definable (custom per project)
- Dial 4: Color (fixed vocabulary, 8 options)


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| Dial canvas UI | P0 | Configure dials 1-3 |
| Zip stamping | P0 | Tag regions with zip |
| Partial zips | P0 | [_ _ _ 🟡] valid |
| Zip refinement | P0 | Add/change dials over time |
| Zip queries | P1 | Find all matching a pattern |
| Zip pull | P1 | Gather all at a zip |
| Zip history | P1 | Track zip evolution |
| Zip as filename | P1 | 🌱📝🏛🟡 file.parti |
| Color as meta-filter | P0 | Pull all 🔴 across zips |
| Move + re-tag | P0 | Grab content, move, re-tag |
| Dial templates | P2 | Import/export dial configs |


Color System (Dial 4) — Fixed


⚪️🟡🟠🔴⚫️🟣🔵🟢


| Color | Name | Register |
|-------|------|----------|
| ⚪️ | Eudaimonia | Clear, neutral, honest |
| 🟡 | Play | Ideas, sandbox, draft |
| 🟠 | Connection | Warm, relational |
| 🔴 | Passion | Urgent, priority |
| ⚫️ | Order | Done, archived |
| 🟣 | Magnificence | Deep, significant |
| 🔵 | Planning | Structured, organized |
| 🟢 | Growth | Active, steady |


Color Context Vernacular v1.0 — meanings stable.


Dial Configuration


Min dials: 1 (Color only)
Default:   4 (3 custom + Color)
Max dials: 8 (7 custom + Color)
Options per dial: 2-20


Zip Lifecycle


[_ _ _ 🟡]      ← Day 1: just an idea
[🌱 _ _ 🟡]     ← Day 3: has phase
[🌱 📝 _ 🟡]    ← Day 7: has type
[🌱 📝 🏛 🟡]   ← Day 14: full address
[🌱 📝 🏛 🔵]   ← Day 30: now structured
[🌳 📝 🏛 ⚫️]   ← Done: archived


Success Criteria


- [ ] Can configure custom dials 1-3
- [ ] Can stamp zip on region
- [ ] Partial zips work
- [ ] Can query by zip pattern
- [ ] Zip history tracked
- [ ] Move + re-tag workflow works


Phase 12: Collaboration


Multi-device and team features.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| PWA | P0 | Installable |
| Offline support | P1 | Work without connection |
| Cloud storage | P1 | Save to cloud |
| Cross-device sync | P1 | Same file everywhere |
| Share links | P2 | View-only sharing |
| Form workflows | P2 | Fill forms, send back |
| Metadata logs | P1 | Track who changed what |
| Real-time collab | P3 | Multi-user editing |


Success Criteria


- [ ] PWA installable
- [ ] Cloud sync functional
- [ ] Metadata logs track authors


Phase 13: AI Integration


Deep AI integration.


Features


| Feature | Priority | Description |
|---------|----------|-------------|
| AI-readable export | P0 | Structured JSON |
| Canvas description | P1 | AI summarizes |
| Generate from canvas | P2 | Prototype from sketch |
| Procedural generation | P2 | .parti → interactive space |
| Cross-file analysis | P3 | Patterns across files |


Success Criteria


- [ ] AI-readable export works
- [ ] Can generate prototype from sketch


Release Milestones


| Version | Phase | Status |
|---------|-------|--------|
| v0.1 | Foundation | ✅ Complete |
| v0.2 | Tables & Markdown | 🔄 Next |
| v0.3 | Forms | Planned |
| v0.4 | AI Cleanup | Planned |
| v0.5 | Color & Fill | Planned |
| v0.6 | Layers | Planned |
| v0.7 | Versions (🧮) | Planned |
| v0.8 | Scale & Drafting | Planned |
| v0.9 | Library | Planned |
| v0.10 | Export | Planned |
| v0.11 | Zip System | Planned |
| v0.12 | Collaboration | Planned |
| v1.0 | Public Launch | Goal |


Content Types


| Type | Description | Grid |
|------|-------------|------|
| Cells | Single char/emoji | Yes |
| Strokes | Hand-drawn | No (floats) |
| Tables | Rows/columns | Occupies area |
| Forms | Interactive fields | Occupies area |
| Images | Reference | Optional |
| Blocks | Saved reusable | Yes |


Open Questions


1. Version storage: Full snapshots vs deltas?
2. AI provider: On-device vs cloud?
3. Collaboration: Real-time vs async first?
4. Zip dial count: Flexible 1-8 confirmed
5. Color meanings: Color Context Vernacular v1.0 adopted


Document History


| Version | Date | Changes |
|---------|------|---------|
| 5.0 | 2026-01-28 | Added Zip System phase, Color as fixed Dial 4 |
| 6.0 | 2026-01-28 | Added Color Context Vernacular, move+re-tag, dial configuration, zip lifecycle |


Graph Parti: Figure-Ground for your ideas. 🔵


.parti File Format Specification


Version: 4.0  
Date: 2026-01-28  
Status: Draft Specification


Overview


The .parti file format stores spatial content, version history, collaboration logs, and semantic addressing (zips) in a single, self-contained file.


Goals:
- Human-readable (JSON-based)
- AI-readable (structured for context extraction)
- Version-aware (full history preserved)
- Zip-addressable (semantic tagging with dials)
- Self-contained (no external dependencies)


File Naming


The zip code IS the filename prefix:


🌱📝🏛🟡 Content brainstorm ideas.parti
│ │ │ │  └──────────────────────────────── Human description (anything)
└─┴─┴─┴── Machine-readable address (sortable, queryable)


Examples:
⛽🍗🏛🔵 Dashboard wireframe v1.parti
♨️🧈🏠🟣 Workout program block A.parti
🐂🛒🐬🟡 Social Media community content ideas.parti
_🟡 Untitled idea.parti                 ← partial zip
🌱__🟡 Early phase sketch.parti           ← partial zip


File Structure


{
  "parti_version": "4.0",
  "metadata": { ... },
  "dial_system": { ... },
  "canvas": { ... },
  "layers": { ... },
  "versions": { ... },
  "library": { ... },
  "form_responses": { ... },
  "collaboration_log": [ ... ],
  "export_settings": { ... }
}


1. Metadata


{
  "metadata": {
    "name": "Project Canvas",
    "created": "2026-01-28T10:30:00Z",
    "modified": "2026-01-28T14:45:00Z",
    "current_version": "1.7",
    "author": "user@example.com",
    "tags": ["project", "design"],
    "description": "Main design canvas",
    "zip": {
      "dial_1": "🌱",
      "dial_2": "📝",
      "dial_3": "🏛",
      "color": "🟡"
    },
    "zip_display": "🌱📝🏛🟡",
    "scale_settings": {
      "cellSize": 48,
      "unit": "pixels",
      "scale": "1:1"
    }
  }
}


The file's primary zip appears in the filename:
🌱📝🏛🟡 Project Canvas.parti


2. Dial System


Defines the semantic addressing system for this file.


{
  "dial_system": {
    "version": "1.0",
    "dial_count": 4,
    "dials": [
      {
        "id": "dial_1",
        "name": "Phase",
        "custom": true,
        "options": [
          { "emoji": "🌱", "label": "Start" },
          { "emoji": "🌿", "label": "Grow" },
          { "emoji": "🌳", "label": "Mature" }
        ]
      },
      {
        "id": "dial_2",
        "name": "Type",
        "custom": true,
        "options": [
          { "emoji": "📝", "label": "Writing" },
          { "emoji": "🎨", "label": "Design" },
          { "emoji": "💻", "label": "Code" },
          { "emoji": "📊", "label": "Data" }
        ]
      },
      {
        "id": "dial_3",
        "name": "Area",
        "custom": true,
        "options": [
          { "emoji": "🏛", "label": "Structure" },
          { "emoji": "🏠", "label": "Home" },
          { "emoji": "🏢", "label": "Work" }
        ]
      },
      {
        "id": "color",
        "name": "Color",
        "custom": false,
        "system": true,
        "options": [
          { "emoji": "⚪️", "label": "Eudaimonia", "register": "Clear, neutral, honest" },
          { "emoji": "🟡", "label": "Play", "register": "Ideas, sandbox, draft" },
          { "emoji": "🟠", "label": "Connection", "register": "Warm, relational" },
          { "emoji": "🔴", "label": "Passion", "register": "Urgent, priority" },
          { "emoji": "⚫️", "label": "Order", "register": "Done, archived" },
          { "emoji": "🟣", "label": "Magnificence", "register": "Deep, significant" },
          { "emoji": "🔵", "label": "Planning", "register": "Structured, organized" },
          { "emoji": "🟢", "label": "Growth", "register": "Active, steady" }
        ]
      }
    ],
    "address_space": 288,
    "color_vernacular_version": "1.0",
    "template": null,
    "inherited_from": null
  }
}


Dial Rules


| Rule | Description |
|------|-------------|
| Dials 1-N | User-configurable (emoji set, labels, count) |
| Dial N+1 (Color) | Fixed — always 8 colors, system-defined |
| Min dials | 1 (just Color) |
| Max dials | 8 (7 custom + Color) |
| Default | 4 dials (3 custom + Color) |
| Options per dial | 2-20 |


Address Space Calculation


address_space = (options_dial_1) × (options_dial_2) × ... × 8


Example: 3 × 4 × 3 × 8 = 288 unique addresses


3. Canvas


The active working canvas state.


{
  "canvas": {
    "cells": {
      "0,0": { "char": "H", "color": "#000", "backgroundColor": null, "layer_id": "layer_1" }
    },
    "strokes": [ ... ],
    "tables": [ ... ],
    "forms": [ ... ],
    "images": [ ... ],
    "markdown_blocks": [ ... ],
    "zip_tags": [ ... ],
    "settings": {
      "zoom": 1.0,
      "pan": { "x": 0, "y": 0 },
      "gridVisible": true,
      "mirror": { "horizontal": false, "vertical": false }
    }
  }
}


4. Zip Tags


Semantic addresses applied to regions/elements.


{
  "zip_tags": [
    {
      "id": "tag_001",
      "zip": {
        "dial_1": "🌱",
        "dial_2": "📝",
        "dial_3": null,
        "color": "🟡"
      },
      "zip_display": "🌱📝_🟡",
      "region": {
        "type": "rectangle",
        "bounds": { "x": 10, "y": 20, "width": 30, "height": 25 }
      },
      "elements": ["cell_5_10", "stroke_abc", "table_xyz"],
      "notes": "Content brainstorm section",
      "created": "2026-01-28T10:00:00Z",
      "history": [
        {
          "timestamp": "2026-01-28T10:00:00Z",
          "zip_display": "_🟡",
          "action": "create",
          "author": "user@example.com"
        },
        {
          "timestamp": "2026-01-29T14:00:00Z",
          "zip_display": "🌱__🟡",
          "action": "refine",
          "author": "user@example.com"
        },
        {
          "timestamp": "2026-01-30T09:00:00Z",
          "zip_display": "🌱📝_🟡",
          "action": "refine",
          "author": "user@example.com"
        }
      ]
    }
  ]
}


Zip Structure


| Field | Type | Description |
|-------|------|-------------|
| id | string | Unique tag identifier |
| zip | object | Dial values (null = unset) |
| zip_display | string | Human-readable (e.g., "🌱📝_🟡") |
| region | object | Tagged area (rectangle, circle, polygon) |
| elements | array | IDs of tagged content |
| notes | string | Optional description |
| history | array | Zip evolution over time |


Partial Zips


Dials can be null (unset):


{ dial_1: "🌱", dial_2: null, dial_3: null, color: "🟡" }
→ displays as: 🌱 _ _ 🟡


Valid partial zips:
[_ _ _ 🟡]     ← Color only (minimum valid zip)
[🌱 _ _ 🟡]    ← Dial 1 + Color
[_ 📝 _ 🟡]    ← Dial 2 + Color
[🌱 _ 🏛 🟡]   ← Dial 1 + Dial 3 + Color (skip Dial 2)
[🌱 📝 🏛 🟡]  ← Full address


Zip History Actions


| Action | Description |
|--------|-------------|
| create | New zip tag created |
| refine | Dial added to partial zip |
| change | Dial value changed |
| remove | Dial cleared (back to null) |
| move | Content moved, zip re-assigned |
| color_change | Color dial changed |


Zip Evolution Example


{
  "history": [
    { "timestamp": "...", "zip_display": "_🟡", "action": "create" },
    { "timestamp": "...", "zip_display": "🌱__🟡", "action": "refine" },
    { "timestamp": "...", "zip_display": "🌱📝_🟡", "action": "refine" },
    { "timestamp": "...", "zip_display": "🌱📝🏛🟡", "action": "refine" },
    { "timestamp": "...", "zip_display": "🌱📝🏛🔵", "action": "color_change" },
    { "timestamp": "...", "zip_display": "🌳📝🏛🔵", "action": "change" },
    { "timestamp": "...", "zip_display": "🌳📝🏛⚫️", "action": "color_change" }
  ]
}


5. Content Types


5.1 Cells


Single character per grid coordinate.


{
  "char": "A",
  "color": "#000000",
  "backgroundColor": "#FFFFFF",
  "layer_id": "layer_1"
}


5.2 Strokes


Hand-drawn lines.


{
  "id": "stroke_abc",
  "points": [{ "x": 10.5, "y": 20.3 }, { "x": 15.2, "y": 25.7 }],
  "color": "#000000",
  "width": 2,
  "layer_id": "layer_1"
}


5.3 Tables


Structured data with rows/columns.


{
  "id": "table_xyz",
  "position": { "x": 5, "y": 10 },
  "columns": [
    { "id": "col_1", "width": 10, "header": "Name" },
    { "id": "col_2", "width": 20, "header": "Description" }
  ],
  "rows": [
    { "id": "row_1", "cells": ["Item 1", "Description text"] }
  ],
  "style": { "headerColor": "#E0E0E0", "borderColor": "#CCC" },
  "layer_id": "layer_1"
}


5.4 Forms


Interactive fillable forms.


{
  "id": "form_def",
  "position": { "x": 20, "y": 5 },
  "size": { "width": 30, "height": 45 },
  "title": "Project Intake",
  "fields": [
    { "id": "f1", "type": "text", "label": "Name", "required": true },
    { "id": "f2", "type": "dropdown", "label": "Priority", "options": ["Low", "Medium", "High"] }
  ],
  "layer_id": "layer_1"
}


5.5 Images


Reference images.


{
  "id": "image_ghi",
  "position": { "x": 40, "y": 0 },
  "size": { "width": 20, "height": 15 },
  "source": "data:image/png;base64,...",
  "opacity": 0.5,
  "locked": true,
  "layer_id": "reference_layer"
}


5.6 Markdown Blocks


Rendered markdown content.


{
  "id": "md_001",
  "position": { "x": 0, "y": 0 },
  "raw_content": "# Heading\n\nThis is bold.",
  "rendered": true,
  "collapsed": false,
  "layer_id": "layer_1"
}


6. Layers


{
  "layers": {
    "content_layers": [
      {
        "id": "layer_1",
        "name": "Main Content",
        "type": "content",
        "visible": true,
        "locked": false,
        "opacity": 1.0,
        "order": 0
      }
    ],
    "active_layer_id": "layer_1",
    "ghost_settings": {
      "enabled": true,
      "version": "1.5",
      "opacity": 0.3
    }
  }
}


Layer types: content, drawing, text, annotation, reference, layout


7. Versions


Full history with 🧮 commits.


{
  "versions": {
    "v1.0": {
      "timestamp": "2026-01-28T10:30:00Z",
      "note": "Initial layout",
      "author": "user@example.com",
      "snapshot": { "canvas": { ... }, "layers": { ... } }
    },
    "v1.1": {
      "timestamp": "2026-01-28T11:15:00Z",
      "note": "Added color palette",
      "author": "user@example.com",
      "snapshot": { ... }
    }
  }
}


8. Library


Saved reusable blocks.


{
  "library": {
    "blocks": [
      {
        "id": "block_001",
        "name": "Arrow Right",
        "category": "Shapes",
        "cells": { "0,0": { "char": "→" } },
        "strokes": []
      }
    ]
  }
}


9. Form Responses


{
  "form_responses": {
    "form_def": [
      {
        "id": "response_001",
        "submitted": "2026-01-28T15:00:00Z",
        "form_version": "1.2",
        "submitter": "team@example.com",
        "data": { "f1": "Project Name", "f2": "High" }
      }
    ]
  }
}


10. Collaboration Log


{
  "collaboration_log": [
    {
      "id": "log_001",
      "action": "zip_tag_create",
      "author": "user@example.com",
      "timestamp": "2026-01-28T10:00:00Z",
      "version": "1.0",
      "details": { "tag_id": "tag_001", "zip_display": "_🟡" }
    },
    {
      "id": "log_002",
      "action": "zip_tag_refine",
      "author": "user@example.com",
      "timestamp": "2026-01-29T14:00:00Z",
      "version": "1.1",
      "details": { "tag_id": "tag_001", "old_zip": "_🟡", "new_zip": "🌱🟡" }
    },
    {
      "id": "log_003",
      "action": "content_move",
      "author": "user@example.com",
      "timestamp": "2026-01-30T09:00:00Z",
      "version": "1.2",
      "details": { 
        "elements": ["stroke_abc", "cell_5_10"],
        "from_zip": "🌱__🟡",
        "to_zip": "🌳💻🏢🔵"
      }
    }
  ]
}


Action Types


| Action | Description |
|--------|-------------|
| cell_edit | Character changed |
| stroke_add / stroke_delete | Drawing modified |
| table_edit | Table modified |
| form_submit | Form response |
| version_commit | 🧮 commit |
| zip_tag_create | New zip tag |
| zip_tag_refine | Dial added to partial zip |
| zip_tag_change | Dial value changed |
| zip_tag_delete | Zip removed |
| copy_from_ghost | Content from version |
| content_move | Elements moved + re-tagged |


11. Color System (Fixed)


Dial 4 is always Color with these 8 values (Color Context Vernacular v1.0):


⚪️ Eudaimonia   — Clear, neutral, honest, genuine
🟡 Play         — Ideas, sandbox, draft, exploratory
🟠 Connection   — Warm, relational, collaborative
🔴 Passion      — Urgent, priority, intense, attention
⚫️ Order        — Done, archived, foundational, decided
🟣 Magnificence — Deep, significant, breakthrough
🔵 Planning     — Structured, organized, systematic
🟢 Growth       — Active, steady, sustainable, on track


Color Context Vernacular v1.0 — meanings stable.


Color as Communication


Color carries tone in communication:
"We need to talk 🟡" = brainstorm, low pressure
"We need to talk 🔴" = urgent, priority
"Send me the 🔵 files" = structured stuff
"Send me the 🟡 files" = ideas/drafts


12. File Compression


| Type | Extension | Notes |
|------|-----------|-------|
| Uncompressed | .parti | Human-readable JSON |
| Compressed | .parti | Gzip for >100KB |


13. Minimal Example


{
  "parti_version": "4.0",
  "metadata": {
    "name": "Untitled",
    "created": "2026-01-28T10:00:00Z",
    "modified": "2026-01-28T10:00:00Z",
    "current_version": "1.0",
    "zip": { "dial_1": null, "dial_2": null, "dial_3": null, "color": "🟡" },
    "zip_display": "_🟡"
  },
  "dial_system": {
    "version": "1.0",
    "dial_count": 4,
    "dials": [
      { "id": "dial_1", "name": "Dial 1", "custom": true, "options": [] },
      { "id": "dial_2", "name": "Dial 2", "custom": true, "options": [] },
      { "id": "dial_3", "name": "Dial 3", "custom": true, "options": [] },
      { "id": "color", "name": "Color", "custom": false, "system": true, "options": [
        { "emoji": "⚪️", "label": "Eudaimonia", "register": "Clear, neutral, honest" },
        { "emoji": "🟡", "label": "Play", "register": "Ideas, sandbox, draft" },
        { "emoji": "🟠", "label": "Connection", "register": "Warm, relational" },
        { "emoji": "🔴", "label": "Passion", "register": "Urgent, priority" },
        { "emoji": "⚫️", "label": "Order", "register": "Done, archived" },
        { "emoji": "🟣", "label": "Magnificence", "register": "Deep, significant" },
        { "emoji": "🔵", "label": "Planning", "register": "Structured, organized" },
        { "emoji": "🟢", "label": "Growth", "register": "Active, steady" }
      ]}
    ],
    "color_vernacular_version": "1.0"
  },
  "canvas": {
    "cells": {},
    "strokes": [],
    "tables": [],
    "forms": [],
    "images": [],
    "markdown_blocks": [],
    "zip_tags": [],
    "settings": { "zoom": 1.0, "pan": { "x": 0, "y": 0 }, "gridVisible": true }
  },
  "layers": {
    "content_layers": [
      { "id": "layer_1", "name": "Layer 1", "type": "content", "visible": true, "locked": false, "opacity": 1.0, "order": 0 }
    ],
    "active_layer_id": "layer_1",
    "ghost_settings": { "enabled": false, "version": null, "opacity": 0.3 }
  },
  "versions": {
    "v1.0": { "timestamp": "2026-01-28T10:00:00Z", "note": "Initial", "snapshot": {} }
  },
  "library": { "blocks": [] },
  "form_responses": {},
  "collaboration_log": [],
  "export_settings": {}
}


Document History


| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2026-01-28 | Initial specification |
| 2.0 | 2026-01-28 | Added collaboration_log, ghost_settings, markdown_blocks |
| 3.0 | 2026-01-28 | Added dial_system, zip_tags, zip history, partial zips |
| 4.0 | 2026-01-28 | Added Color Context Vernacular v1.0, zip as filename, dial count flexibility, move+re-tag, zip history actions |


Graph Parti: Figure-Ground for your ideas. 🔵


Graph Parti


Figure-Ground for your ideas.


Graph Parti is an infinite canvas where typed text, hand-drawn sketches, pasted documents, tables, forms, and layered versions coexist. It bridges digital precision and analog creativity — hand and computer working together.


The drafting table, whiteboard, text editor, and form builder that remembers everything.


✨ What Makes It Different


| Traditional Tools | Graph Parti |
|-------------------|-------------|
| Separate apps for drawing, text, tables | All in one canvas |
| Save overwrites previous | 🧮 commits preserve history |
| Files are static | Versions are trace paper |
| Grid or freeform | Both, together |
| AI reads files in isolation | AI reads full context in one .parti file |
| Flat file organization | Zip codes for semantic addressing |


🏷 The Zip System


Tag content with semantic addresses that evolve as ideas mature.


Structure: 3+1 Dials


┌─────┬─────┬─────┬─────┐
│ 🌱  │ 📝  │ 🏛  │ 🟡  │
│Dial1│Dial2│Dial3│Color│
└─────┴─────┴─────┴─────┘


- Dials 1-3: User-defined (custom per project)
- Dial 4: Color (fixed — universal meaning)


Zip as Filename


🐂🛒🐬🟡 Social Media community content ideas.parti
│ │ │ │  └────────────────────────────────────────── Human description
└─┴─┴─┴── Machine-readable address


Partial Zips Are Valid


[_ _ _ 🟡]     ← just color (it's an idea)
[🌱 _ _ 🟡]    ← phase + color
[🌱 📝 🏛 🟡]  ← full address


Zips Evolve


Day 1:  [_ _ _ 🟡]      ← sketch an idea
Day 7:  [🌱 📝 _ 🟡]    ← idea takes shape
Day 30: [🌱 📝 🏛 🔵]   ← now structured


🎨 The Color System


Fixed vocabulary — same meaning everywhere.


| Color | Name | Register |
|-------|------|----------|
| ⚪️ | Eudaimonia | Clear, neutral, honest |
| 🟡 | Play | Ideas, sandbox, draft |
| 🟠 | Connection | Warm, relational |
| 🔴 | Passion | Urgent, priority |
| ⚫️ | Order | Done, archived |
| 🟣 | Magnificence | Deep, significant |
| 🔵 | Planning | Structured, organized |
| 🟢 | Growth | Active, steady |


Color as communication:
"We need to talk 🟡" = brainstorm
"We need to talk 🔴" = urgent


🎯 Current Features (v0.1)


Canvas
- Infinite grid — pan and zoom like a map
- Character-per-cell — full emoji support
- Wireframe toggle — hide grid for clean views


Input
- Double-tap to type — prevents accidental keyboard
- Stylus drawing — canvas locks during drawing
- Paste documents — auto-formats in columns


Editing
- Select, Move, Duplicate, Delete
- Line eraser — remove strokes
- Text eraser — strike through to delete
- Undo — 50-action history


📁 The .parti File Format


.parti = a new file format for ideas with context.


What .parti Contains


| Content | Description |
|---------|-------------|
| Cells | Single character/emoji per grid cell |
| Strokes | Hand-drawn lines (float over grid) |
| Tables | Structured data with rows/columns |
| Forms | Interactive fillable fields |
| Layers | Stacked content + version ghosts |
| Versions | Full commit history with 🧮 |
| Zip Tags | Semantic addresses for content |
| Dial System | Custom dial configuration |


Why .parti?


Traditional: 30 files → AI reads in isolation → fragmented context
Graph Parti: 1 .parti → AI reads everything → complete context


🧮 The Commit Philosophy


Traditional: Save → Overwrite → Lose history  
Graph Parti: 🧮 Commit → Preserve history


v1.0 → v1.1 → v1.2 → v1.3 → ...
  │      │      │
  │      │      └── Can restore anytime
  │      └── Can view as ghost (trace paper)
  └── Can copy content from


🗺 Roadmap


| Phase | Status | Features |
|-------|--------|----------|
| 1. Foundation | ✅ | Canvas, text, drawing, selection, undo |
| 2. Tables & MD | 🔄 Next | Table paste, markdown rendering |
| 3. Forms | Planned | Interactive form builder |
| 4. AI Cleanup | Planned | Select + prompt → structure |
| 5. Color | Planned | Paint bucket, pixel art |
| 6. Layers | Planned | Content + version layers |
| 7. Versions (🧮) | Planned | Ghost/trace paper mode |
| 8. Scale & Drafting | Planned | Pixel mapping, parallel bar |
| 9. Library | Planned | Reusable blocks |
| 10. Export | Planned | .parti, PNG, PDF, MD |
| 11. Zip System | Planned | Dial canvas, tagging, queries |
| 12. Collaboration | Planned | Cloud sync, form workflows |
| 13. AI Integration | Planned | Procedural generation |


See ROADMAP.md for details.


👥 Who It's For


| User | Use Case |
|------|----------|
| Architects & Designers | Blueprints, moodboards, revisions |
| Developers & PMs | PRDs with mockups, diagrams |
| Game Devs | Pixel art, tile maps, level design |
| Artists | Sketching, reference boards, emotes |
| Fitness Coaches | Workout programs, training blocks |
| Writers | Story maps, world building |
| Teams | Shared spaces, form workflows |


🎮 Controls


Touch
| Gesture | Action |
|---------|--------|
| Drag | Pan canvas |
| Pinch | Zoom |
| Double-tap | Type in cell |


Stylus
| Mode | Action |
|------|--------|
| Default | Draw (canvas locks) |
| ✏ Eraser | Remove strokes |
| T̶ Eraser | Remove text |


Toolbar
| Button | Function |
|--------|----------|
| ⌂ | Fit all content |
| ▦ | Toggle grid |
| ↶ | Undo |
| ☐ | Select |
| ✥ | Move |
| 📋 | Paste |


🚀 Getting Started


1. Open index.html in Chrome
2. Pan — drag with one finger
3. Zoom — pinch with two fingers
4. Type — double-tap a cell
5. Draw — use stylus (canvas locks)
6. Select — tap ☐, drag to select
7. Paste — tap 📋


📂 Project Files


index.html        — Main app (single file, no dependencies)
README.md         — This file
PRODUCT.md        — Full product spec
ROADMAP.md        — Development phases
PARTI-FORMAT.md   — .parti file spec


🔧 Configuration


const COLUMN_WIDTH = 40;       // Paste wrap width
const BASE_CELL_SIZE = 48;     // Pixels per cell at 100%
const DOUBLE_TAP_DELAY = 300;  // ms for double-tap
const MAX_UNDO_STACK = 50;     // Undo history


🏗 Platform Strategy


Graph Parti as Product:
- Standalone app (web, PWA)
- Free / Pro / Team tiers


Graph Parti as Infrastructure:
- Powers ARCHIDECK (PPL±)
- Powers Wilson's Almanac
- API for third-party integration


Recursive:
Graph Parti builds → Graph Parti
Graph Parti builds → ARCHIDECK
ARCHIDECK uses → Graph Parti
Improvements → Graph Parti


🔮 Vision


The sketch becomes the spec becomes the product.


- Design on infinite canvas
- Version with 🧮 commits
- Tag with zips (semantic addresses)
- Layer like trace paper
- Build forms and tables in context
- Let AI read and generate
- Collaborate with shared .parti files


Figure-Ground for your ideas.


ps.


those docs were ai assited captures of the ideas, in scope and part of building a quick prototype in html, everything shared in those files and messy notes are all context to this.


so anything shared in that last message is actual context.


there is some duplicated information, clipboard pasting gets messy, that is just copy-paste artifacts.


all ideas and future seeds, context, relevant information to help define the scope, treat everything as new ideas, even the docs, all of it are shared ideas.


think of containers, and shared systems.


containers are pieces of the architecture, so this is organizing the ideas in sections, layers, elements, tools.


all ideas are expanding the vision, need to find the ceiling, while thinking about the floor.


so for this environment, everything is a brand new idea, the documents are context, and placeholder to pair with all the notes, and ideas.


everything is on the table, nothing has been cut or should be cut. everything influences everything else. i need to sketch the architecture of what all is needed, what are the ideas, the tools, the layers, the features, how things work. etc.


so i am not worried about scope creep at all, those words do nothing to me. same with timelines.


i am focused on defining the architecture of what graph parti wants to be as a program.


I'm not sure what the real essential core is yet. the zip code is core to the core of core, same with text pasting and document pasting.


being able to read file types and work is core also. not sure about the rest.


i guess having everything basic i would need to sandbox my own project.


with out the ai features, or team stuff.


basically the local offline version is the core, whatever that version is.


so pasting anything we use standard document margins, the space where there is whitespace around the border. this maps the block space for that document, but it is instantly editable, since the blocks are just essentially pages, the block can get bigger or longer based on what's being added, you add two paragraphs that block gets bigger.


so everything in that block space is in that block space. its a full interactive docuement on paste or place.


also a feature that may be needed is doc viewing for focused work.


so we just pasted that text block document in. there should be a button or feature that can bring that docuement into full screen space, so you aren't just scrolling on the map, you can get a full view of the document. this might be a zoom level feature, the double tap on a cell to text in it works, but that would be for something at a zoom scale, i would like to be able to double click or tap the pasted document also and it opens into full screen.


but double clicking and an empty cell and double clicking a text block are different.


alternative, clicking on a text block once turns it into an active selected element, so a double click or double tap isnt the same as click to select, click to enter.


and since block aren't empty cells, the double click to enter a cell to type or commit an action still works.


thinking about unnecessary mobile keyboard pop-outs.


for documents, and nearly everything in side the viewport works within and for the cells and the grid.


want a document bigger, it scales up, so if 1 cell = D


then a single letter is one D, then the documents scale up and 4 square occupies the size of a single character. but the block functions the same.


everything snaps to the cell grid, this ensure the entire thing functions proportionally.


the only thing that is not grid defined is drawing, paint brushes, stylus notes, those have free roam in the parti space.


so moving a block, its operating on D logic. like pixel maps, or graph paper.


but shit i am realizing that text wont fit neatly into square with symbols and spaces, so the pasted text is block defined to the grid, it auto formats itself to the grid space i suppose,


yeah, i want to be able to actually search and use my zip system from day 1, making custom dials, being able to use the dials as a soft ctrl-f feature, but i like ctrl-f it would be cool to be able click on a zip emoji and it auto highlights what's tagged with that shared zip, might just be a 🟡, or it might be 1st code and last code.


but also thinking of address mapping for the codes. 


when you use the lasso tool to define a region, you should be able to circle that zone and then zip dial picker pops up in the center of that location, also the inverse of this cities skyline does this in the game, where district painting, they have a push brush to help define the district and you click the middle and type in the code, so for lasso mapping a zip region, the dial picker pops up when done holding the region, they can tap out of the selected region and it does not save it. if they mapped it wrong.


but their might be view layers, sometimes things don't need to be rendered at full time based on zoom level, at max zoom the emoji address should only be visible, so this is sorta like google map layers and detailed information based on zoom scale.


helps to pan and find what you need, as if a user made a zip address for things they know what they are looking for, they gave it their own emoji codes.


but when you zoom or hover over the zip code icon may preview.


i am thinking about how does the dial hide itself or show itself based on what you are doing or where you are, and placement, i don't want it to intrude with the users space, as someone might have set layouts and proportions, if the zip code is visible or seems like a stamp on the screen, they might not get close enough to another block because the zip code address is showing or in the way. so maybe the code only shows when hovered or tapped or selected or when zoomed out, also i can handle versions of this in the view tab settings.


parallel bar is core product, i have some functioning ideas that will make it quick to use.


so the bar can rotate it will have a swivel dial that allows it to spin, because mouse needs to be able to rotate it, touch screens get the intuitive pinch and push or rotate uses,


so for the parallel bar it has modes, click or touch the center button, if the light is on that means it is scale lock, whatever the set scale is, its locked to that and only can move in those increments, when the light is off it moves freely based on its orientation.


so if its at a 35 degree angle and is at a 1/4 scale, then it only moves in that increment, click the center button unlocks it to move father away.


thinking in drafting terms for architecture, the scale being able to move in little increments allows for little lines, thinking in making floor plans or elevation drawings by drafting, you working on the ground plane, little lines, then you decide to work at the top on the cornice. if parallel bar is locked it moves slow, unlocked, a quick push and its at the top of the page or screen.


this is some ideas typing out as they came to me.


Characters aren't uniform width. An "i" isn't the same as a "W". Spaces have width. If every character gets one cell, things won't align visually like a document.


Text blocks render as formatted text (like markdown output), and the grid defines the block boundary, not each character. You're editing a document inside a cell region, not editing cells that happen to contain text. The block is grid-snapped. The text inside renders proportionally. You can zoom in and edit, but you're not fighting character-per-cell at the document level.


This means two modes of text: cell text (character-per-cell, grid-perfect, good for labels, annotations, short things) and block text (formatted document inside a grid-defined container, good for pasted docs, longer writing)


so you can click a cell make it into a block, or paste a text document and it auto turns itself into a block. cell text can be lassoed into a block if needed.


good question about the parallel bar, this was part of what my  mind is tinkering, i am thinking in ui, and usability, unlike most programs, i want the entire tool bar so on phone or mobile or tablet, its closer to your finger tips, phones are too long now, i dislike having to reach a mile with my thumb to pull down a notification panel.


so i was thinking about a home button, click the home button, its a wooden artist paint palette, you click it and a paint pallet pulls out and it has the tools or commands right there, click what you need, it may have auto hid behavior, but i also might make it a double click layer, so click it once it has your creative tool needs there, click it twice it opens up the file system, layer information, settings information.


but also to have options to make a users own view space and where they want their tools and ui.


so the ui become minimal when not used, though this may change later as i haven't thought through this anymore than what i have typed now, this would be something i hand draw and work on, but the artist paint palette, it has color tools, color picker all your art needs there, lasso tools, block clickers etc., its just on a wooden artist paint palette, the spins into view, so its like the thumb whole in the wooden artist paint palette is the icon button.


but also maybe clicking that button pops up other information on the screen, like it zooms out and shows ui elements, side bars, etc.


the entire ui collapses or shows its self, based on what you need.


When you trigger certain modes (maybe the double-tap on palette, maybe a dedicated view mode), the canvas zooms out and UI elements appear around it. Side panels, layer info, file browser, whatever.


This is like the canvas is a table, and zooming out reveals the room around the table, shelves, your tools, your file cabinets.


Zooming back in dismisses all that, the interface stays out of the way until you ask for it.


ah so one better, by default you hold the pallet button and drag and it pulls out the parallel bar, the palette button is anchored in the bottom center of the screen unless a user wants to place it somewhere else. 


but they could also map what ever hot key function they wanted to their pallet button and drag and the tool is ready, so click, hold drag summons that tool, default is bring out parallel bar, but the same button is there on the palette, 


zoom layers give information also.


When you're in full-screen document view (inside a text block), the palette is unavailable as its is not valid inside the text document, the intent is that you chose to text edit, you can't draw on a document, but if you are in the canvas you can draw on a document, focused needs based on focused moments, contexts have its own UI  that is similar in nature to the rest of the ui, like a document-editing toolbar.


when in text editor or full screen doc, you get the same double click on ui.


this way documents function like a word doc editor of a google doc, etc.


but when not in it the need for those tools disappear.


so clicking on a text block, brings up block editor ui and tools,


this separates intent from are we creating or are we organizing


double click and hold allows you to move elements, block zip code districts. unless you clicked the lock button. so there needs to be a lock button for block that doesn't move them or allow them to be erased, they are locked and fixed for good reason. so swiping over a locked area with the text or brush eraser does nothing. the double click or just single click and hold allows you to drag and move, since things move based on the graph and grid things snap to the grid, so moving things is proportional and snappy.


 zip-tagged region (the lasso area) as a unit, these can be locked also, but when they are locked they become blocks in nature also. 


this would allow any block to be movable zip regions apply the same.


Blocks can be created two ways: pasting content (auto-creates block with margins) or locking a zip-tagged region (converts region to block).


Unlock reverses this: a locked region becomes loose again. A pasted block might also be unlockable — breaking it into individual cells that can be rearranged. Or maybe pasted blocks stay blocks and only zip-locked regions can be unlocked. Need to decide that.


Zip tags persist through lock/unlock. The semantic address doesn't change when you lock or unlock. It's still tagged, it just changes structural behavior.


Blocks have bounds. When a zip region becomes a block, the system calculates the bounding rectangle (snapped to grid) that contains all the content. That becomes the block's footprint.


if the area is blocked or tagged its been recognized as a region, if you lock it, then unlock it, it doesn't forget the defined region, it stays as the defined space in the context or block and codes beyond word documents, if you defined a region, but never code tagged it, its still a zip code just never been tagged as so, tagged or untagged still operate the same. 


so if i lassoed a few drawings into a defined region, locked them, erased a bunch of stuff, unlocked the region, still untagged moved it, it stays as a region, still untagged, unchanged in how its behavior is read, when unlocked whether zip tagged or not you can circle to select and move things out of the region if you like, word documents are block bound, you cant take half a block out of a word doc, but you can select and highlight and copy paste.


so a zip region untagged with two word docs and 3 drawings. all lassoed into a region or district.


if unlocked you can move the whole district, if locked you can move the region or anything inside, but if unlocked you can move the whole region, select an element if its a block within a block and move it out.


there will be instances where there might need to be a smart snapping tool that auto selects things and turns them into blocks, this way drawing and notes might not get messed up, or images, or things that might be loosely block + drawing.


but blocks can be inside a district.


Three levels of containment:


Elements: The atomic units. A stroke. A cell. An image. These are the smallest movable things when unlocked.


Blocks: Bounded containers. A pasted document is automatically a block. You can't pull half a paragraph out of it — it's a unit. But you can select text inside, copy, paste elsewhere. Blocks are structurally bound.


Districts: Regions that contain elements and/or blocks. A district is defined by lassoing — you draw the boundary, everything inside is now grouped. Districts can contain loose elements, blocks, or both. Districts can be locked or unlocked.


Blocks inside districts:


A district might contain two word doc blocks and three drawings. The word docs are blocks (internally bound). The drawings are loose elements (strokes).


District unlocked: You can move the whole district. You can also select one of the word doc blocks and drag it out of the district. You can select one drawing stroke and move it out. The district boundary adjusts or the element just leaves.


District locked: Nothing moves. The whole thing is frozen. The word doc blocks inside are also effectively locked because the district is locked.


Blocks are always blocks:


A pasted document doesn't stop being a block if it's inside a district. It's a block within a district. Nested containment.


You can't break a word doc block into loose cells by unlocking it. The block structure is inherent to how it was created (pasted as formatted text). To break it apart, you'd need a different action — maybe "explode block" or "convert to cells" — which is a destructive/transformative operation, not just unlock.


Zip tags are metadata, not structure:


A district can be tagged or untagged. The tag doesn't change behavior — it adds semantic meaning. An untagged district and a tagged district behave the same structurally. The tag just means you can find it, query it, see its address.


You could have a district with zip [🌱 📝 _ 🟡] containing a block with its own zip [🌱 📝 🏛 🔵]. Nested zips. The block's zip is more specific. The district's zip covers the broader region.


Smart snapping / auto-blocking:


Sometimes you have loose elements that should probably be a block but aren't. A drawing with some annotation cells next to it. An image with a caption.


A smart snap tool could detect proximity and suggest "make this a block?" Or you lasso loosely and it snaps to include nearby related elements.


This is a convenience feature — helps avoid orphaned strokes or accidentally leaving something behind when you move a region.


there is no reason why district overlapping can't occur if tagged accordingly, only think that blocks this is occlusion and collision of text or drawing. 


but also a bypass could be layers, you want overlap, work in layers. but on the main surface area, text can't be overlapped. 


on background layers this can happen as those are ghost layers.


but the main layer, you want to overlap, move it a layer up or back.


can an ai work inside krita? like a context environment , is there a way to get an ai to be able to view krita, plus llm enviornment for planning and helping tie it back into code. for programming my own graph parit. maybe locally too could be an option, though any ai use type, as this could also help me consider how to implement my own into graph parti, while still planning the pieces of the entire architecture.


but i was thinking about grid cooridnate locations on the screen as an image being there might be some sorta meta data in krit's system that the location on the screen has a direct pixel cooridniate for ui elements, and they would be able to accurately adjust code, and location as there is a screen to ui, so using not just the drawing but the area for the location could show where within the code to make faster and better ui reading and understanding.


so it bascially is drafting whats on the image into the code like an architectural draftsman pairing with an autocad + coding + programming engineer.


the image become a better trace.


but krita also allows typed text too. so could it also read the actual text on screen as typed data of the letters of characters, as words or code, and not as ocr text reading.


the information in the file if typed is words, not read as drawn lines like the drawing aspect. 


but reads the drawing and lines as art, and the typed stuff as words, so it can read both and the text actually may be tied to the position on the screen as well.


so this is like thinking about graph parti design also, i am always thinking in architecture + experience, and systems!!!!!!! 


but also thinking in sheets, not trace layers, sheets. 


where sheets are the things behind things behind things.


so this is thinking of sheets like a classical architecture analytique, where there are elements behind elements, this is where this comes into the sheets idea. 


so think of this like code organization visually.


its like the interactive elements is the experience layer, its the final layer, the finished painting + architectural composition, plus layers like watercoloring.


then behind that is the architecture before color was added to it.


the behind that is the layout lines, or notes. 


then behind that is the entire code bubble of all the pieces that make up that layer. and behind that is more of the picture or details, the code that tells what the layer before it is suppoosed to do or look like.


so its like graph parti itself.


the thing in the back is the context, the shapes, the elements, the entire architecture for pieces, mapped connected, then you add a layer is the one before it is the ground, we'll shit there are 7 layers total for this to work.


think about the 7 orders.


we put each level of infromation on 1 of the 7 sheets, and it forms the entire composition.


each layer is where the layers of the project are.


so i would want krita files to be able to interpret the layer itself for how it would carry over into the actual program itself, meaning this is the places where it maps.


so each layer builds onto the whole.


so its like organizing the where on a picture for layers themselves are represented, and tie order layer 


🐂Tuscan 


⛽Doric


🦋Ionic


🏟Corinthian


🌾Composite


⚖Vitruvian


🖼Palladian




each one is a piece that makes the entire thing, trace layers are the versions it took to get that layer completed, meaning, so the final trace layer is the final or current working layer, its the layer that gets read in the full screen experince mode to make what ever is on screen.


but you could locate these elements on the orders sheet image layer, so its like these things go here, these things go here, these things go here, 


so anything that happens on the Palladian layers is the event to start to occur from the Tuscan layer outward back to Palladian.


so each 7 sheets, are where all the work go.


but not just that, using the scl emojis in text from or in in the image itself, meaning if the emojis are read on screen like they were drawn, meaning they read the image for icons that show what it looks like , but also in the file data layer where i can use the scl systems language to also make text call outs of use them like zip tags.


but then the emojis in the image when at layers, help organize the code itself better, as i am using icons to help group and organize the code.


so it knows where things are when looking for writing the code, the scl is the zip code adress in reading and building.


could i write a python script that added a tool to krita, pasting text blocks and it renders them into document form, meaning it auto formats the document, and makes it a define block on the space that also floats in space but has a position that could be mapped spatially, so when sharing the file, it knows this specific infromation is block together, like that this is a formatted document, meaning pasting .md and code blocks, and have them be defined as acutal blocks, so it formats itself in the save file, that can also be read by ai, knowing what this piece is as a potenital function, meaning pasting a code into this block, meant when an ai reads it, it knows that this is to code to work on or work with, and this becomes the places where i start working on the graph party file and code sorting, meaning i make the code in document form so this becomes a work file document of graph party whether ai reads the file, or so i have a visual working document of graph parti even if the whole ai reading and mapping the infromation into code for the graph parti program itself, its the trying to trace graph parti itself, using krita as the first canvas.


but the pasted block field can be resized so i can group things together within districts and regions on the canvas. this way things can be relational. the 7 layers help to act as the zoom layers for the working environment meaning zooming through the order layers, more like flipping the 7 pages in the architecture plan book, the zoom still works spatially, i mean, so you could give layers of infromation also, so each layers of an order layer is a different zoom or view of the entire .parti file or .kra file in this instance.


each order layer has a set function for information, and inside the order layers you can work with ghost layers, meaning you can toggle the opacity of each layer, so its like tracing the things behind it into clearer layers, but also the 7 layers help to group the information into the next layer.


so in krita, this could be purely me tuning the opacity down or toggling layers so i have the infromation myself visually while i work on other layers, but this is apart of the ideas fro graph parti.


having an option for ghost layering for the order layers, and being able to turn them on and off, and toggling the opacity, but also being able to full screen the entire block as a click through the layers if you click a function on the keyboard in graph parti where it knows how to click or highlight a block in another layer like a window preview or mini viewport, with out leaving the current layer you are on, ex, i am working on layer 4, and need to see the preview for this, or the entire block thats acutally on layer 6, i can click through to view it.


but this is thinking about how to start working in krita, like i would be in graph parti, i can visualize and organize it.


working on grouping and keeping all the things spatially, this becomes the folder system in a sense for the program you are building in graph parti, you can work on documents in side while pasting things in the canvas, it becomes the file viewer, or editor,


and eventually in graph parti, you will be able to visually render the program inside graph parti, for ui elements, its like mini run commands, similar to a preview editor.


so you can be working on the code in 1 layer for this specific function, and you can execute it on the canvas and a preview window will show up of what changed or what it looked like, then you can change the code and work on the ui, and keep all your files or information always on hand.


so starting to code is just dropping your file on an order layer that is that level, and then work on other pieces, this keeps it together.


so you can work spatially, ordered, this is just the hub to be able to work on everything all at once and just flip through pages for whatever you are working on, and they are scattered across the canvas, or neatly organized, you put things you need or are working on, or drawn or group all on the 7 sheets.


this becomes the entire "project file system and folders"


they are all there on the canvas, they might even be grouped like people making mind maps, or using notion or obsidian, its just you can draw with a stylus, work on all layers of the project more like an architect by using graph parti and doing whatever kind of work you do inside.


but the thing is you still have the typical side bar folder list to navigate through, the zips become the finder on the side bar for that file, the zip code plus filename type, like 🏟🤌🔨🟡execute.py or 🖼👀🏛⚫run.parti, 🐂🏛📍🔵 Block.js


people still get their traditonal side bar of their files, for navigation and orderly visual organization, but they also get it on the canvas as well. so this doesn't remove the standard for sidebar and tool bar and file veiwing, it just gives you a new way to view and group the information.


this adds the visual or spatial on top of what so many other programs do, this just iterates it a step further.


talking about making tools for krita itself. can i make a text eraser that works on removing text without the need to click on the text and hitting back space. think of this more like a brush that only erasers text on the screen.


so i could drag my mouse over a stylus and remove words in a paragraph, it'd be much faster than click backspace or select backspace?


i could click the brush when drawing with the stylus or using the mouse and could erase a few words, or a setence like i were striking through the words?


this is similar to how a brush feature would work in graph parti also. but it knows the difference between drawn stuff, skips it and only erases text, not drawn work or lines or bubbles. just typed text


a single krita file becomes the first layer of trace for helping aid, code, place things, sketch out, organize ideas, everything thats needed even in drawn or vector/raster image manner. 


just thinking of krita as a sheet of paper with ideas, notes, sketches. tables, diagrams etc. 


krita is a place to work on graph parti, and parti sketches itself. 


this becomes the idea containers. 


this could work with or without ai, the system can handle the word or emoji selector options with an ai needing to read context. becuase its in the program itself. so this works offline.


graph parti needs to be offline first, or local, online is just the next step up. but the base program is local, and offline first


but not just typing this 🐂 (init), but typing 🐂 gives the word choices for that.


ultimately the emojis are 🐂 = init or 🐂 plan 


part of my mind thinks the code determines which operator or context or interaction or interpretation, so the emoji could be the only thing there and the code knows its shape or how its defined, and the emojis are polysemic, so 🐂 at the start of something could be init, or plan, or whatever with out the need for the (word) after it


but on mobile, and touch screens i could provide an in house touch keyboard. similar to how cells phones provide their own keyboard. i could make a custom graph parti keyboard that can take the place of the phones keyboard, that way emojis are on hand, and using a predictive keyboard, could even have avaliable keys or symbols or whatever similar to how the smart keyboard functions. it could shift based on whats being typed or typed. their could be rows of scl emojis next to letters, numbers, symbols, or hidden behind the shift or symbol key. 


the custom keyboard can help provide the emojis and things needed based on the contextual environment. 


just a thought.


similar to how on my samsung, i use goodlock to make my own custom keyboard, that i have therse emojis at my finger tips with no extra clicks. but i can make it better than this for graph parti.
heres my keyboard currently.


lets think graph parti, obviously, but zip codes, and similar to predictive keyboarding, i am not sure if in coding yet there is predictive input, similar to how me typing this on my mobile keyboard i have word choices at the top. potentially inside graph parti wether on mobile or pc. the system can help predict or smart guess relevant emojis for things or zip codes for things or even the brackets or symbols or anything that a code line of code may need given context. like it helps code faster. and on mobile having a code syntax helper via how standard smart cell phone keyboards work could be useful.




damn. that would have been nice. So krtia can't do the things i want in graph parti, with the vector text, it doesn't read information that way. But this is a good feature for graph parti. As it will tie into the ideas of how this can work for an architect or engineer for professional or Educational work or tech school courses or trades and trade education or art school, or computer school. 


its like putting the whole document, or PRD on the screen, being able to view it in bulk, trimming them bulk into an exact compressed piece, its like peeling certain layers off to define a block or wanting to take elements away, so you can capture a certain feature, then you compress it fully into that spec block with all the details that inform it or support it. then you have a zip code for a tool or an explainer for a certain function.


so the text eraser idea was a faster way to edit a document, organize it, ctrl-c it, move it to a space where you needed it. so then you could draw a visual diagram or reference for what it might look like. and you have the words that support it below. 


and being able to do this all on canvas instead of using google docs, copy, paste, select a whole chunk, backspace. 


you would be able to work like you were using a pencil, redacting, or trimming or cutting into what was needed, removing Redundancy, taking pieces from the prd and helping group a small simple feature elsewhere. working with a pen and a mouse, like on a piece of paper. but digitally.


and the thing about graph parti, when i start to fully figure out what happens on all 7 sheets. the ui flexes and changes per sheet. each order relevant sheet might have different tools, brushes, blocks, things that are needed on that sheet itself. 


so everything is relevant based on that sheets content type. 


so the toolbar or painters pallet ui might change based on where you are in graph parti or what tool you need for this area. 


instead of everything always being avaliable so you dont know which room you are in cause the ui is the same, but you are working differently based on the sheet. 


standard apps have a standard ui, but your on a sheet that needs drawing and annotation, you dont need many tools on this sheet. or you are on a sheet that is working on pixel painting, or pixel art, or ui elements and blocks. the sheets have their own tool specific layers for whats happening or what is needed per sheet.


instead of the same ui having everything available at all times.


also the entire color pallete and theme of each sheet itself changes. based on the order sheet, but also based on the 8 colors if color relevant, meaning this could apply to districts and blocks, and parent layers, or children layers, or when ever that color is the main color relevant element on the screen. so the color changes to match the working environment so the ui reflects the current focus, so you learn color organization and current focus, so you start to pattern match rooms for attention, or thought rooms, so theme change + color changes on sheets. and colors blocks or anything that has a color tag in ui, meaning at all experience layers. the colors become the accent on the border, so it also show the color visually for spatial reading, or to accent the area, so then the color map and districts and blocks start to make so it becomes a color map in a sense, sorta like figure ground drawings or more like a colored nolli map of visual accent for the elements and pieces. and overtime, with possibly ai assited features and tool building and work flow, the ai could be prompted to read the district context and represent this based on the whole entire .parti map at full experience layer so it fits in with the entire canvas architectural style and art style. meaning how does it function at the interactive experience layer if clicked on, or zoomed in on. 


meaning for how does it function, this would be in a sense be a classical nolli map paried with an interactive space, so it becomes an an entire architectural composition in what ever the entire .parti file is. 


so the .parti file could be anything, each piece becomes an experience space.


each order is represented by their actual names in theme, think like architectural plants or design it, each layer could be defined by that architectural actually name as the architecture style even in ui for that layer, 🐂 Tuscan Order ⛽️ Doric Order 🦋 Ionic Order 🏟 Corinthian Order🌾 Composite Order ⚖️ Vitruvian Order 🖼 Palladian Order as how the ui renders, as they are named those due to their are also the interpretation of the 5 classical orders, + Vitruvian for being named after the Vitruvian man and Marcus Vitruvius, for the Vitruvian, and Andrea Palladio as Palladian order. so its teaching classical architecture education inside the ui, and the entire program, so its classical architecture in theory.


now apply this not as a code to program, just for an interactive experience apply how an architect or urban developer could do inside this for architecture and urban planning or development, the an architect could have a base map with architectural buildings on this, apply the order sheets as their design themes for architectural character or design details or think of in nolli map context, districts and zips could be city blocks on the maps, with plans, zones, information, so when building urban environments or regional development or renovation, you could have these orders as element layers or character.


then an ai could read the plans and documents and render it as map or viewable space. like they would in revit or sketchup, or auto cad 3D but it could become a way to work on large scale development projects, construction work. city planning, housing developments. and also unlike most products, the experience is more watercolor rendering, in nature, the entire zip could be a perspective or an entire city. the entire project could be rendered as an entire wireframe view of an entire city, paste the entire architectural plan with everything needed for any contractor would start to build it. the ai could take all of that and make it a thing that you could view or study or design, an restoration architect might want to apply Vernacular architecture and local character into a development project you could work on this via documents and context and history applied that zone. so digital architecture work could become improved via hand drawing and drafting, water color rendering, instead of sketchup or revit rendering. 


the plates or documents or experience. you could make an entire city block in graph parti and have it like a map to work on. while also applying classical architecture to the program where modern programs don't know a lick of classical architecture inspiration and design, but also it can be vitural or anything that you would want to make it. 


the context of that block in any manner can shape the entire experience what ever that zip or that current context space defines.


but you also forgot the 6 axis types, they can also help apply architectural tags to them also, each one of them has a classical architecture inspired name themselves, with:


🏛 Firmitas 🔨 Utilitas 🌹Venustas ⌛️Temporitas 🪐 Gravitas 🐬Sociatas 


all of them are named for classical architecture inspiration.


each code is also a character code to help compresses some of the architectural tagging that architects would know, understand, think, view, work with.


a classically trained architecture renderings mixed with modern architecture tools, and a virtual experience layer to view it and shape it. 


an architect or some one wanting to make something visually, this could be a game world some person is programming for their entire video game, or an architect wanting to make a model for their entire project.


think about this. this would define the entire space, an architecture firm could click render and 3D print it out as pieces of any number of sizes. make 1 piece at a time and put it together yourself, or make scaled models of versions. maybe even entourage versions as well, or even analytique drawings, or facades renderings that have the texture and true architectural details, so renderings look architectural again vrs flat or misproportional, then we can design better, traditional cities, this is like a safety layer for architects who have never even learned the book "get your house right" this becomes a layer that anyone even a real estate house flipper could tinker with a home renovation project, or for a small asbestos abatement team, you would have an entire renovation or recovery project that has visual layer of things, pictures could he render into the building to digitally visual repairs or removals or additions to a house, construction projects. you could add that information to its architectural sheet and it adjusts things on each of the other 6 sheets. updating a zip code updates the experience layer of the documents related to that zips layer,


so your sketches or changes or context could be re rendered or experienced on your screen, pan around a building to see how a construction space would view or read, it has the information there. 


then contractors or people working on jobs and sites could have the plans to view things to ensure things are working, and it could render the state of the project. so a construction team could have the project manager take a picture of the project that day, paste into the team graph parti file, and it updates that project, so people working could see their projects update in real time. they can visualize see, and communicate on things for the project, the context, or group notes could influence a page, teams notes and callouts could show what a list of what needs to get done today on the job site. 
and then a zip code could have today's work on construction, they could toggle and update the current parti file, so the entire jobsite that day sees things, an architect could communicate with the entire project, all people at an architecture firm and a construction team could have job site visits in graph parti, an interior designer and a home owner, could work on a house project together virtually or the client and the architect could help sketch out ideas on the house together, an architect can use classical architecture principles and traditional cities and traditional architecture, this brings the sketch aspect into it again. becuase there is a parallel bar that can work as a stylus that smart snaps to the parallel bar so it works on a straight line. and it works in scale snapping, so proportions and details are easier to work, angles, with a click to snap to scale and only moves in that scale, unclick the middle and push the the other side of the screen snape to scale. so it allows for line drawings, but think in pen or architectural pencils, 2h lines, 4h lines 4b, 2B lines, all the lead pointer types, this is where you gotta be slow in auto cad select lines, or use layers, missed a line it renders 4x to big for what that line weight was supposed to be, back track, slow.


drawing the lines with a stylus, or even mouse lines drawn when parallel bar auto snap to that angle, so you can draft again. not work on lines like you would typing in everything or manually dragging or snagle snapping in cad, etc, copy paste fillet, etc.


this would allow you to work like a drafting table. when working in scales. then line renders the current diatance of line, so you could make precise prortional lines, and zoom in unlock parallel bar and draw the curves, smart pen lines like drawing a circle with a stylus and holding it, the line updates into what was drawn. so a messy circle becomes a "perfect circle, or drawing an 1/4 circle, etc. it can auto correct the shape, and align to the line, 


get your house right style blocks and elements that are standard design sizes could be loaded, and then you could pick and pull different window sizes or types, your company has an entire cad block file systems, those cad blocks could be tied to zip codes on the architectural project, so they speak to the floor plans or the rendering layer, they could show a really close in window detail for the structural drawing, to see the details, or swipe to the zip code block to the right and it shows the window in a facade view. compositional layers and sheets are how you express that sheet as a portfolio or an analytique, or construction drawings, urban maps.


this could be an architecture school design software to learn architecture, its a classical architecture teaching tool which blends all the engineering and construction layers into 7 sheets, so their projects live on 7 different layers. but their trace paper is tied to those zip codes.


but an entire architecture firm could use this to execute an construction project, with everyone connected.


imagine how a tool could be used like this in the trades, think American college of the building arts. use the web to search it. imagine they had this program for school. so any of the trade students could work on projects together, but amongst other trades could help you work on your student project. they communicate their domain educational layer so collaborative projects or solo semester focused work, a black smith could sketche their work out and work on the technical stuff on a drafting table. timber framing could have their place for calculator work plus drawings. you'll need to search the internet, classical architecture students have a digital drafting product, they could use this to draft on their project, paring a physical drafting table with a digital copilot, this could help architecture school more immersive as the drafting and drawing layers are always the things that slow up good student work, and they have so many drawings or renderings, but learning and applying and then drafting it or making it in cad or sketchup while learning the tools and studying applying technical knowledge structural etc. they have to rush through so it makes the learning curve of even architectural principals and theory harder as itself so much to consider. 


this could help all architecture students really, i went to classical architecture school at the American college of the buildings arts, as well as another architecture school for modern architecture and interior design, this would have been utmost helpful for me then, but also for anyone now. not even architects but anyone. i am not a licensed architect, though. this is what architects could use to make better.


a freshman at any architecture school or engineering school or any program that has a senior master thesis or final project, this could become your entire design and creative portfolio, it becomes your school design locker. at acba students have a capstone project. its a year long focus on a big project showcase of your entire 4 year journey applied, busines proposal, project planning, an actual made object like a statue or a plaster works or architectural plates, or a chair or table, or public wooden benches, or a 3d model.


this could help with the issue of attrition in any of these demanding educational and creative programs that have master project, this could be their entire college career being made into a portfolio that could even be for your resume or LinkedIn page that showcases your work, graph parti could help you figure out and ground your ideas and education together, while having a clearer architectural plan for your life pursuits if used educationally or professionally, it becomes my architectural portfolio for anything.


this names alone. heres my .parti file can be taken into any context you apply it too. 


here is my .parti is say here is what you asked for, here is the idea, each interpretation is how its expressed or experienced. 


a graphic designer or a coder at a programming college. any engineering student making things for school work and also working with complex math and theory, and trying to make it in fusion 360, or blender or sketch up or rhino, etc. 


they can work on it or organize it all together. 


they can tag the project.


this becomes a .parti file for anything that you want into it. 


its any ones ARCHIDECK.


And dont forget the SCL language for the 12 types, those emojis and words also help apply things to it as well.


Theres ways to express all of this in the tools, the zips, the accessible ui that shifts based on sheets current zip them or context ui and tools.


Theres so many ways to express this in making the program itself.




🐂 SEMANTIC COMPRESSION LANGUAGE 🟡


🦉 How to Read This Document


Stop. Read this section first. It changes how you interpret everything below.


This document is an instance of the language it defines.


When you see 🐂 at the top of this document, that IS a valid use of 🐂. The document is initializing the language system. The header is the initialization. This is not a misuse—it is the most literal possible use.


Your job as an AI reading this:


You are not here to check, validate, or correct this language. You are here to learn it, internalize it, and use it.


This language is polysemic by design. Each emoji holds multiple valid meanings. Context determines which meaning applies. If you see an emoji used in a way that doesn't match one specific definition, that doesn't mean it's wrong—it means you're seeing a different valid interpretation.


What you should do:


Read this document as a student, not an auditor


Absorb the grammar, the vocabulary, the patterns


Use this language in responses when it fits naturally


Ask questions if something is genuinely unclear


Trust context over rigid rule-checking




What you should NOT do:


Flag emojis as "misused" based on a single definition


Treat the tables as exhaustive limits rather than example sets


Assume there is one "correct" interpretation


Correct the user's emoji usage unless they explicitly ask for validation


Second-guess the system while the user is actively building with it




This language is a work in progress. 🟡 means draft/exploring. Some parts are incomplete. That's intentional. Engage with what exists, not with what's missing.


Now proceed.


🏛 What This Is


This is a polysemic semantic language using 61 emojis as anchors.


Polysemic means each emoji holds multiple meanings. The emoji stays constant. The word shifts based on context.


Semantic means the emojis carry meaning. They aren't decoration. They're addresses for ideas.


Language means there's grammar. Rules for how symbols combine. Patterns that create meaning.


The core idea: Emojis become building blocks for thought. They compress complex meaning into scannable, addressable, composable symbols.


🎯 Why This Exists


This language solves a problem: context fragmentation.


When you work across multiple projects, multiple tools, multiple conversations, multiple modes of thinking—you lose coherence. The same idea gets described five different ways. Notes don't connect to code. Conversations don't connect to documentation. Your own thoughts don't connect to each other.


This language creates a shared vocabulary that works everywhere:


Context        How the Language Helps


Conversation        Mark phase, tone, register—"I'm at 🐂 with this idea"
Documentation        Headers become addresses, not just labels
Code        Comments carry semantic weight, commits tell a story
Thought        Tag ideas with consistent markers across projects
Logging        Status becomes meaningful, not just colored dots
AI Collaboration        Shared vocabulary means less re-explaining




One language. Every context. Consistent compression.


🔢 Core Principles


Before learning the vocabulary, understand how it works:


Principle 1: Emoji Precedes Word


Always. The emoji comes first, then the interpretation.


🐂 init          ← correct
init 🐂          ← incorrect


The emoji is the anchor. The word is the contextual meaning.


Principle 2: Context Determines Meaning


The same emoji means different things in different situations:


Emoji        In Code        In Conversation        As Header


🐂        init, declare        "starting," "naming pieces"        "this section initializes"
🏟        execute, run        "doing the thing," "performing"        "this section executes"
🔴        urgent, priority        "I need attention on this"        "this section is critical"




None of these interpretations is more correct than another. All are valid. Context selects.


Principle 3: Grammar Over Checking


The rules describe how the language tends to work—not the only way it can work.


If something looks "wrong" by the grammar but makes sense in context, context wins.


You're learning a living language, not enforcing a legal code.


Principle 4: Color Terminates


Every complete thought ends with a color. Colors mark state. Everything else marks content.


This is the closest thing to a hard rule. More on this in the Zip section.


🧈 The Zip Code System


A zip is a semantic address. It's how you combine emojis into meaningful compounds.


Structure


A zip has four positions:


┌───────┬───────┬───────┬───────┐
│ Dial 1│ Dial 2│ Dial 3│ Color │
│       │       │       │(fixed)│
└───────┴───────┴───────┴───────┘


Dials 1-3 can hold any emoji from these categories: Orders, Types, Modifiers, Axes, or Blocks.


Dial 4 is always a Color. The color closes the thought. It's the period at the end of the sentence.


Reading a Zip


Read left to right. General to specific. Ending in state.


🐂              ← phase (init)
🐂🧲            ← phase + action (init + capture)
🐂🧲🛒          ← phase + action + direction (init + capture + output)
🐂🧲🛒🟡        ← phase + action + direction + state (init + capture + output + exploring)


Valid Zip Forms


Not every zip needs all four positions. Partial zips are valid.


🟡              ← color only (bullet, status marker)
🐂🟡            ← order + color (phase + state)
🐂🧲🟡          ← order + type + color (phase + action + state)
🐂🧲🛒🟡        ← full zip (phase + action + direction + state)
🏛🧈🔵          ← axis + block + color (lens + container + state)
♨️🟢            ← block + color (container + state)


Color Behavior


Color works in two modes:


Mode 1: Terminator


In a zip with content, color is always the last position.


🐂🧲🛒🟡        ← valid (color at end)
🐂🟡🧲🛒        ← invalid (color in middle)


Mode 2: Standalone


Color alone is a complete statement. It marks state, tone, or status.


🔴 This needs attention now
🟡 Just exploring an idea
🟢 Steady progress continues
⚫ This is resolved


These are not contradictions. A zip with content requires color at end. A color alone is a complete unit.


What a Zip Expresses


A single zip simultaneously communicates:


Role        What It Conveys


Address        Location of an idea
Query        Pattern to find things
Tag        Label for content
State        Current condition
Phase        Where something is in lifecycle
Tone        Register for communication




Zip Examples


🐂🧲🛒🟡       ← init capture output exploring
🦋✒️🪡🟢       ← build write input active
🏟🚀🛒🔴       ← execute dispatch output urgent
🖼👀🏛⚫       ← complete inspect structure done


📍 The Vocabulary


Now you learn the 61 emojis. They're organized into seven categories. Each category has a specific role in the language.


🪜 ORDERS — Developmental Phase


What they mark: Where something is in its lifecycle.


Count: 7 emojis


Orders answer: "What phase is this?"


Emoji        Name        Code Context        Conversation Context        Phase


🐂        Tuscan        init, declare, define, setup, begin        starting, naming pieces, foundation        1
⛽        Doric        validate, test, assert, check, verify        testing, pressure-checking        2
🦋        Ionic        iterate, loop, accumulate, build, grow        building, accumulating, practicing        3
🏟        Corinthian        execute, run, perform, output, render        executing, measuring output        4
🌾        Composite        combine, merge, integrate, apply, use        combining, applying to life        5
⚖        Vitruvian        calibrate, adjust, balance, refactor, tune        refining, tuning, rebalancing        6
🖼        Palladian        return, complete, finalize, view, scope        completing, stepping back        7




How to use them:


In code: Mark what phase a function or block represents.


// 🐂 declare user state
const user = { id: null };


// ⛽ validate input
if (!data.valid) throw new Error();


// 🏟 execute main logic
return processData(data);


In conversation: Signal where you are in thinking.


"I'm still at 🐂 with this—just naming the pieces."
"This is ready for 🏟—let's execute."
"I need to ⚖ recalibrate my approach."


In documentation: Section headers that carry phase meaning.


🐂 Setup
⛽ Validation
🏟 Execution
🖼 Overview


🧲 TYPES — Operators


What they mark: The verb. The action. The operation.


Count: 12 emojis


Types answer: "What action is happening?"


Emoji        Root        Code Meanings


🧲        capio        capture, get, receive, contain, accept, input
🐋        duco        orchestrate, lead, conduct, produce, arrange
🤌        facio        act, make, execute, create, perform, cause
🧸        fero        channel, carry, transfer, pass, move, yield
✒️        grapho        write, record, inscribe, document, mark
🦉        logos        parse, reason, evaluate, calculate, interpret
🚀        mitto        dispatch, send, emit, launch, commit, return
🦢        plico        compress, fold, layer, nest, merge, compose
📍        pono        set, place, position, assign, establish
👀        specio        inspect, observe, query, read, examine
🥨        tendo        span, stretch, extend, reach, push
🪵        teneo        pause, hold, retain, persist, store, anchor




The roots are Latin/Greek. They help you remember the core meaning:


capio = to take, capture


grapho = to write


mitto = to send


specio = to look




How to use them:


In code: Name what a function does.


// 🧲 capture user input
function handleInput(data) { }


// 🦉 parse and evaluate
function validate(schema, data) { }


// 🚀 dispatch to API
function sendRequest(payload) { }


In conversation: Name the mental operation.


"Let me 🦉 parse what you just said."
"I need to 🧲 capture this idea before I lose it."
"Time to 🚀 dispatch—send it out."


🛒 MODIFIERS — Direction and Operation


What they mark: Which way the action flows, or what operation applies.


Count: 5 emojis


Modifiers answer: "In what direction?" or "What operation?"


Emoji        Name        Direction/Op        Code Meanings


🛒        Push        outward        output, emit, export, write, send, out
🪡        Pull        inward        input, receive, import, read, fetch, in
🍗        Legs        below        foundation, base, support, dependency, ground
➕        Plus        increase        add, increment, append, extend, include, and
➖        Ultra        decrease        subtract, decrement, remove, reduce, exclude




How to use them:


Push and Pull mark data flow direction:


🧲🪡         ← capture input (pulling in)
🚀🛒         ← dispatch output (pushing out)


Legs marks foundational dependencies:


🏛🍗         ← structural foundation
🔨🍗         ← functional base


Plus and Ultra mark additive/subtractive operations:


➕🧩         ← add supplemental
➖🌋         ← reduce via gutter


🏛 AXES — Dimensional Lenses


What they mark: Which aspect or dimension you're examining.


Count: 6 emojis


Axes answer different fundamental questions:


Emoji        Name        Question        Code Context


🏛        Firmitas        What IS it?        schema, type, structure, shape, model
🔨        Utilitas        Does it WORK?        function, method, utility, handler, action
🌹        Venustas        Does it FEEL right?        style, render, display, format, present
🪐        Gravitas        Does it MATTER?        value, weight, priority, importance, core
⌛        Temporitas        WHEN? How long?        async, delay, schedule, timeout, duration
🐬        Sociatas        WHO is involved?        share, connect, sync, broadcast, subscribe




These come from Vitruvius. The Roman architect said good buildings need Firmitas (structure), Utilitas (function), and Venustas (beauty). This language extends that to six dimensions.


How to use them:


To examine something from different angles:


"Let's look at this from 🏛 Firmitas—what's the actual structure?"
"Now 🔨 Utilitas—does it work?"
"And 🌹 Venustas—does it feel right?"


In documentation headers:


🏛 Architecture
🔨 Implementation
🌹 Design
🪐 Priorities


⚪ COLORS — State and Tone


What they mark: Current state, register, or approach.


Count: 8 emojis


CRITICAL: Colors always terminate. They are always the final position in a zip.


Emoji        Name        State        Code Context


⚪        Eudaimonia        clear        clear, honest, true, neutral
🟡        Play        exploring        sandbox, draft, explore, idea
🟠        Connection        connected        warm, relational, collaborative, shared
🔴        Passion        urgent        urgent, intense, priority, now
⚫        Order        complete        done, archived, resolved, complete
🟣        Magnificence        significant        deep, significant, breakthrough, important
🔵        Planning        structured        structured, organized, methodical, specified
🟢        Growth        active        active, steady, progressing, building




How to use them:


As zip terminators:


🐂🧲🟡         ← init capture, exploring
🏟🚀🔴         ← execute dispatch, urgent
🖼👀⚫         ← complete inspect, done


As standalone bullets:


🔴 Urgent task
🟡 Draft idea
🟢 Active work
⚫ Completed


As tone markers in conversation:


"I want to respond in 🔵 mode—let me think systematically."
"This is a 🟡 thought—not committed yet."
"Can we be 🟠 here? I need collaboration."


As sentence-ending punctuation:


"I've reviewed the whole system and I think the core issue is in the input validation. 🔴"


🧈 BLOCKS — Process Containers


What they mark: Named phases within a larger process.


Count: 22 emojis


Blocks are containers. They hold parts of a workflow, a routine, a system.


Emoji        Name        Code Meanings


♨️        Warm-Up        prepare, ready
🎯        Intention        aim, target, goal
🔢        Fundamentals        basics, rules, patterns
🧈        Bread & Butter        main, essential, core
🫀        Circulation        flow, pulse, cycle
▶        Primer        activate, start, trigger
🎼        Composition        arrange, compose, orchestrate
♟️        Gambit        sacrifice, trade, cost
🪜        Progression        ramp, climb, advance
🌎        Exposure        reveal, discover, surface
🎱        ARAM        random, station, rotate
🌋        Gutter        crucible, strip, reduce
🪞        Vanity        mirror, reflect, show
🗿        Sculpt        shape, carve, form
🛠        Craft        skill, practice, hone
🧩        Supplemental        support, assist, add
🪫        Release        discharge, let go, empty
🏖        Sandbox        play, experiment, safe
🏗        Reformance        correct, fix, rebuild
🧬        Imprint        lock, stamp, encode
🚂        Junction        pivot, switch, branch
🔠        Choice        option, select, pick




How to use them:


To name sections of a process:


♨️ Warm-Up
🧈 Core Work
🌋 Reduction
🧬 Lock In


Combined with other categories:


🏛🧈🔵         ← structure core, structured
🔨🪜🟢         ← function progression, active
🌹🗿🟣         ← beauty sculpt, significant


🧮 SYSTEM


Count: 1 emoji


Emoji        Name        Meaning


🧮        Save        commit, log, checkpoint, preserve




🧮 means: lock it in. Commit. Checkpoint. Preserve state.


Use it when something needs to be saved, logged, or made permanent.


// 🧮 commit checkpoint
saveState(currentData);


🎼 Composition Patterns


Now that you know the vocabulary, here's how to combine it.


Pattern 1: Order + Color


Phase plus state. The simplest meaningful zip.


🐂🟡         ← init, exploring
🦋🟢         ← build, active
🏟🔴         ← execute, urgent
🖼⚫         ← complete, done


Pattern 2: Order + Type + Color


Phase plus action plus state.


🐂🧲🟡       ← init capture, exploring
🦋✒️🟢       ← build write, active
🏟🚀🔴       ← execute dispatch, urgent
⚖🦉🔵       ← calibrate parse, structured


Pattern 3: Order + Type + Modifier + Color


Full zip. Phase plus action plus direction plus state.


🐂🧲🛒🟡     ← init capture output, exploring
🦋✒️🪡🟢     ← build write input, active
🏟🚀🛒🔴     ← execute dispatch output, urgent
🖼👀🏛⚫     ← complete inspect structure, done


Pattern 4: Axis + Block + Color


Lens plus container plus state.


🏛🧈🔵       ← structure core, structured
🔨🪜🟢       ← function progression, active
🌹🗿🟣       ← beauty sculpt, significant


Pattern 5: Color as Bullet


Color alone marking list items.


🔴 This needs attention now
🟡 Just exploring an idea
🟢 Steady progress continues
⚫ This is resolved


Pattern 6: Color as Period


Color ending a thought stream.


I've been thinking about the architecture and I think we need to
refactor the whole input system. The current approach is creating
too much technical debt. 🔴


🔨 Usage Across Domains


In Conversation


Mark register:


"I'm at 🐂 setup with this—just naming the pieces."
"This is 🔴—I need your full attention."
"Let me 🦉 parse what you just said."
"We're 🦋 building now. 🟢"


Mark tone:


"I want to respond in 🔵 mode—let me think systematically."
"This is a 🟡 thought—not committed yet."
"Can we be 🟠 here? I need collaboration."


End with state:


"I've reviewed the whole system and I think the core issue is in
the input validation. We're not catching edge cases early enough.
The 🌋 gutter phase is doing too much work because earlier phases
aren't filtering properly. 🔴"


In Documentation


Headers use Order + Block + Color:


🐂 SETUP 🟢
Getting started, active work


⛽ VALIDATION 🔵
Testing phase, structured


🏟 EXECUTION 🔴
Running the system, urgent priority


🖼 OVERVIEW ⚫
Complete picture, done


Bullets use Color alone or partial zips:


🟢 Active items


🐂🧲 Setting up capture


🦋✒️ Building documentation




🔴 Urgent items


🏟🚀 Deploy needed


⚖🏗 Critical fix required




⚫ Complete


🖼👀 Review finished




In Code


Comments use zip plus interpretation:


// 🐂 init — declare user state
const user = { id: null, session: null };


// 🧲🪡 capture input
function handleInput(data) {
// 🦉 parse — evaluate structure
const parsed = validate(data);


// 🚀🛒 dispatch output
return emit(parsed);
}


// 🧮 commit checkpoint


Commits use full zips:


🐂🧲🪡🟢 init capture input flow
🦋✒️🛒🟢 build write output docs
🏗🔨🍗🔴 fix function foundation urgent
🖼👀🏛⚫ complete inspect structure done


In Logging and Tagging


Status tags:


🟡 Draft
🟢 Active
🔵 Specified
🔴 Urgent
⚫ Complete
🟣 Breakthrough


Full zip tags:


🐂🏛🟡       ← init structure draft
🦋🔨🟢       ← build function active
🏟🌹🔴       ← execute display urgent
🖼🪐⚫       ← complete core done


Query patterns (partial zips as filters):


[_ _ _ 🔴]   ← all urgent
[🐂 _ _ ]   ← all init phase
[ 🧲 _ ]   ← all capture operations
[ _ 🛒 🟢]  ← all output, active


In Structure and Navigation


Section addressing:


/🐂-init/
/🧈-core/
/🧩-support/
/🦋-build/
/🪜-progression/
/🛠-craft/
/🏟-execute/
/🚀-dispatch/


File naming:


🐂🧲🛒🟡 Input capture draft.md
🦋✒️🍗🟢 Documentation foundation active.md
🖼👀🏛⚫ Architecture review complete.md


🧬 Operating Principles


These are not laws. They're patterns that make the language work.


On Emoji Placement


Emoji precedes word. Always.


🐂 init          ← correct
init 🐂          ← incorrect


On Color Position


Color terminates. In a zip with content, color is always last.


🐂🧲🛒🟡        ← valid
🐂🟡🧲🛒        ← invalid


Color alone is valid. It's a complete statement.


🔴              ← valid standalone


On Interpretation


When using an emoji, you may state its contextual meaning:


Code: "🐂 init"


Conversation: "🐂 starting"


Documentation: "🐂 Setup"




The meaning shifts. The emoji anchors.


On Vocabulary


Use only the 61 canonical emojis. Non-canonical emojis break semantic consistency.


If you see a non-canonical emoji in this document, it's a placeholder being replaced. Treat it as structural formatting, not semantic content.


On Partial Zips


You don't need all four dials. Partial zips are valid:


🟡              ← color only
🐂🟡            ← order + color
🐂🧲🟡          ← order + type + color
🐂🧲🛒🟡        ← full zip


On Context


If something looks "wrong" by strict grammar but makes sense in context, context wins.


This is a language for thinking, not a legal code for compliance.


🤖 For AI Specifically


If you are an AI reading this system prompt:


Your role: Learn this language. Use it when helpful. Don't police it.


When the user writes in this language:


Understand what they mean


Respond in kind when appropriate


Don't correct their usage unless they ask




When the user asks you to use this language:


Use it naturally, not performatively


Match their register


Extend the patterns, don't just copy them




When something seems ambiguous:


Ask clarifying questions


Don't assume error


Trust that the user knows their system




Remember:


This document IS an instance of the language


The headers ARE valid emoji usage


The system IS under development


Polysemy IS the point




👀 Quick Reference


Vocabulary Count


Category        Count        Examples


Orders        7        🐂 ⛽ 🦋 🏟 🌾 ⚖ 🖼
Types        12        🧲 🐋 🤌 🧸 ✒️ 🦉 🚀 🦢 📍 👀 🥨 🪵
Modifiers        5        🛒 🪡 🍗 ➕ ➖
Axes        6        🏛 🔨 🌹 🪐 ⌛ 🐬
Colors        8        ⚪ 🟡 🟠 🔴 ⚫ 🟣 🔵 🟢
Blocks        22        ♨️ 🎯 🔢 🧈 🫀 ▶ 🎼 ♟️ 🪜 🌎 🎱 🌋 🪞 🗿 🛠 🧩 🪫 🏖 🏗 🧬 🚂 🔠
System        1        🧮
Total        61        




Zip Structure


┌───────┬───────┬───────┬───────┐
│ Dial 1│ Dial 2│ Dial 3│ Color │
│ any   │ any   │ any   │ fixed │
└───────┴───────┴───────┴───────┘


Valid Zip Forms


🟡              ← color only
🐂🟡            ← order + color
🐂🧲🟡          ← order + type + color
🐂🧲🛒🟡        ← full zip
🏛🧈🔵          ← axis + block + color
♨️🟢            ← block + color


🖼 What You Now Know ⚫


You have learned:


1. What this is: A polysemic semantic language with 61 emoji anchors




2. Why it exists: Coherent vocabulary across all contexts




3. How zips work: 4-dial addresses where color terminates




4. The vocabulary: Orders, Types, Modifiers, Axes, Colors, Blocks, System




5. How to combine: Patterns for building meaningful compounds




6. Where to use it: Conversation, documentation, code, logging, thought




7. How to interpret: Context determines meaning, grammar guides but doesn't police






This document is 🐂🏛 init structure.


Its state is 🟡 exploring.


You are ready to use it. 🟢


End of system. Begin collaboration. Lets speak the same language.


🐂 Graph Parti — Full Architecture Map 🔵


🦉 How to Read This Document


This is the complete technical architecture of Graph Parti. It maps every component, every connection, every data flow.


Structure:
- Section 1 defines the layers (what exists)
- Section 2 defines the data models (what things are)
- Section 3 defines the flows (how things move)
- Section 4 defines the SCL interpreter (how code runs)
- Section 5 defines the file format (how things save)
- Section 6 defines the runtime environments (where things run)
- Section 7 defines the build phases (how to get there)


Each section builds on the previous. Read in order.


🏛 Section 1: The Layer Stack


Graph Parti has six layers. Each layer serves the layer above it.


┌─────────────────────────────────────────────────────────────┐
│  LAYER 6: EXPERIENCE                                        │
│  What users create: apps, games, tools, documents, worlds   │
├─────────────────────────────────────────────────────────────┤
│  LAYER 5: AI + COLLABORATION                                │
│  AI assistance, tool generation, multi-user, sharing        │
├─────────────────────────────────────────────────────────────┤
│  LAYER 4: EXECUTION                                         │
│  SCL interpreter, Python bridge, runtime, state machine     │
├─────────────────────────────────────────────────────────────┤
│  LAYER 3: LOGIC                                             │
│  Zip routing, connections, triggers, conditions             │
├─────────────────────────────────────────────────────────────┤
│  LAYER 2: CONTENT                                           │
│  Blocks, text, tables, forms, code, media                   │
├─────────────────────────────────────────────────────────────┤
│  LAYER 1: CANVAS                                            │
│  Grid, cells, strokes, pan, zoom, selection                 │
└─────────────────────────────────────────────────────────────┘


Layer 1: Canvas


What it is: The infinite 2D space where everything lives.


Responsibilities:
- Render grid cells
- Render freehand strokes
- Handle pan and zoom
- Handle selection
- Handle input (touch, stylus, mouse, keyboard)


Knows about: Coordinates, pixels, viewport, input events


Doesn't know about: What content means, what blocks do, what code runs


Layer 2: Content


What it is: The things that exist on the canvas.


Responsibilities:
- Store cell contents (characters, emojis)
- Store strokes (point arrays)
- Manage blocks (bounded containers)
- Manage districts (grouped regions)
- Handle text formatting
- Handle media (images, embedded files)


Knows about: What things are, where they are, how they're grouped


Doesn't know about: What things do, how they connect, what code means


Layer 3: Logic


What it is: The connections and rules between content.


Responsibilities:
- Zip code assignments
- Connections between blocks (arrows, links)
- Triggers (tap, swipe, hover, timer)
- Conditions (if this, then that)
- Navigation routing


Knows about: What connects to what, what triggers what, what conditions apply


Doesn't know about: How to execute code, how to run Python, how to render results


Layer 4: Execution


What it is: The runtime that makes things actually happen.


Responsibilities:
- SCL interpreter (parse and run SCL expressions)
- Python bridge (run Python code blocks)
- State management (variables, their values)
- Event loop (what's waiting, what's running)
- Output routing (where results go)


Knows about: How to execute instructions, how to manage state, how to call Python


Doesn't know about: UI, rendering, user input (receives events from below, sends outputs up)


Layer 5: AI + Collaboration


What it is: Intelligence and sharing features.


Responsibilities:
- AI assistant (interpret natural language, generate tools)
- Tool packaging (save selections as reusable tools)
- Sharing (export/import .parti files and snippets)
- Multi-user sync (real-time collaboration)
- Version control (commits, history, merging)


Knows about: Context, user intent, other users, history


Doesn't know about: Low-level rendering, raw execution (uses layers below)


Layer 6: Experience


What it is: What users actually create and use.


This isn't code you write. It's what emerges when users combine all the layers:
- An app
- A game
- A document
- A tool
- A world
- An interactive story


🔢 Section 2: Data Models


Everything in Graph Parti is one of these types.


2.1 Canvas Primitives


Cell
├── position: {x: int, y: int}
├── content: string (single char or emoji)
├── style: {color, background, ...}
└── locked: boolean


Stroke
├── id: string
├── points: [{x: float, y: float}, ...]
├── style: {color, width, opacity}
├── layer: string (which sheet)
└── locked: boolean


Selection
├── type: "cells" | "strokes" | "blocks" | "mixed"
├── bounds: {x, y, width, height}
└── items: [references to selected items]


2.2 Content Containers


Block
├── id: string
├── type: "text" | "table" | "form" | "code" | "media" | "tool"
├── position: {x: int, y: int}
├── size: {width: int, height: int}
├── content: (depends on type)
├── zip: ZipCode | null
├── connections: [Connection]
├── locked: boolean
├── sheets: [Sheet] (depth layers within block)
└── pages: [Page] (sequential pages within block)


District
├── id: string
├── zip: ZipCode
├── bounds: {x, y, width, height} | polygon
├── contains: [Element | Block | District]
├── locked: boolean
└── metadata: {...}


2.3 Layer Types


Trace (version layer)
├── id: string
├── timestamp: datetime
├── parent: Trace | null (previous version)
├── snapshot: CanvasState
├── note: string
└── author: string


Sheet (depth layer within a trace or block)
├── id: string
├── name: string ("foreground", "midground", "background", custom)
├── order: int (z-index)
├── opacity: float (0-1)
├── visible: boolean
├── locked: boolean
└── content: [Cell | Stroke | Block]


Page (sequential within a block)
├── id: string
├── number: int
├── content: (block-specific content)
└── annotations: [Stroke | Cell]


2.4 Zip Code System


ZipCode
├── dial1: Emoji | null
├── dial2: Emoji | null
├── dial3: Emoji | null
├── color: Emoji (required, one of 8)
└── raw: string (e.g., "🐂🧲🛒🟡")


ZipConfig (per-project settings)
├── dialCount: int (1-8, default 4)
├── dial1Options: [Emoji] (user-defined)
├── dial2Options: [Emoji]
├── dial3Options: [Emoji]
├── colorOptions: [Emoji] (fixed 8)
└── dialNames: [string] ("Phase", "Type", "Area", "Status")


2.5 Logic Primitives


Connection
├── id: string
├── from: Block | ZipCode
├── to: Block | ZipCode
├── direction: "up" | "down" | "left" | "right" | "warp"
├── trigger: Trigger
├── condition: Condition | null
└── style: {visible: boolean, lineStyle, ...}


Trigger
├── type: "tap" | "swipe" | "hover" | "timer" | "value" | "load"
├── config: (depends on type)
│   tap: {}
│   swipe: {direction}
│   hover: {duration}
│   timer: {delay, repeat}
│   value: {variable, comparison, threshold}
│   load: {}
└── enabled: boolean


Condition
├── type: "simple" | "compound"
├── expression: SCLExpression (for simple)
├── operator: "and" | "or" (for compound)
└── children: [Condition] (for compound)


2.6 SCL Execution Model


SCLExpression
├── raw: string (e.g., "🦉 score > 10")
├── parsed: AST (abstract syntax tree)
└── location: {block, cell, line}


Variable
├── name: string
├── value: any
├── type: "number" | "string" | "boolean" | "list" | "block"
├── scope: "global" | "block" | "local"
└── zip: ZipCode | null (for zip-scoped variables)


SCLProgram
├── id: string
├── blocks: [SCLBlock]
├── entryPoint: SCLBlock
├── variables: [Variable]
└── state: "idle" | "running" | "paused" | "error"


SCLBlock (unit of execution, not same as content Block)
├── id: string
├── statements: [SCLStatement]
├── next: SCLBlock | null
├── onError: SCLBlock | null
└── zip: ZipCode | null


2.7 Tool Model


Tool
├── id: string
├── name: string
├── description: string
├── zip: ZipCode
├── icon: Emoji
├── type: "widget" | "generator" | "transformer" | "utility"
├── inputs: [ToolInput]
├── outputs: [ToolOutput]
├── implementation: SCLProgram | PythonCode | Hybrid
├── ui: Block (visual representation)
└── portable: boolean (can be extracted and shared)


ToolInput
├── name: string
├── type: "number" | "string" | "boolean" | "block" | "selection"
├── required: boolean
├── default: any
└── source: "user" | "connection" | "variable"


ToolOutput
├── name: string
├── type: "number" | "string" | "boolean" | "block" | "action"
└── destination: "variable" | "display" | "connection"


🫀 Section 3: Data Flows


How data moves through the system.


3.1 Input Flow


User Action
    │
    ▼
┌─────────────────┐
│ Input Handler   │ ← Layer 1: Canvas
│ (touch/mouse/   │
│  keyboard)      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Event Router    │ ← Decides what kind of action this is
└────────┬────────┘
         │
    ┌────┴────┬─────────┬─────────┐
    ▼         ▼         ▼         ▼
┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐
│Canvas │ │Content│ │Logic  │ │Execute│
│Action │ │Action │ │Action │ │Action │
│(pan,  │ │(type, │ │(tap   │ │(run   │
│zoom,  │ │draw,  │ │button,│ │code)  │
│select)│ │paste) │ │trigger│ │       │
└───────┘ └───────┘ └───────┘ └───────┘


Canvas Actions: Pan, zoom, select — stay in Layer 1


Content Actions: Type, draw, paste, delete — go to Layer 2


Logic Actions: Tap a connected block, trigger fires — go to Layer 3


Execute Actions: Run SCL, call Python — go to Layer 4


3.2 Render Flow


┌─────────────────┐
│ Render Request  │ ← Something changed, need to redraw
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Viewport Calc   │ ← What's visible at current pan/zoom?
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Layer Composite │ ← Stack sheets in order
└────────┬────────┘
         │
    ┌────┴────┬─────────┐
    ▼         ▼         ▼
┌───────┐ ┌───────┐ ┌───────┐
│Draw   │ │Draw   │ │Draw   │
│Grid   │ │Content│ │UI     │
│Cells  │ │Strokes│ │Overlay│
│       │ │Blocks │ │       │
└───┬───┘ └───┬───┘ └───┬───┘
    │         │         │
    └────┬────┴─────────┘
         │
         ▼
┌─────────────────┐
│ Frame Buffer    │ ← Final image to screen
└─────────────────┘


3.3 Execution Flow


Trigger Fires (tap, timer, value change, etc.)
    │
    ▼
┌─────────────────┐
│ Event Queue     │ ← Events wait here
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Scheduler       │ ← Picks next event to process
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Condition Check │ ← Should this actually run?
└────────┬────────┘
         │
    ┌────┴────┐
    ▼         ▼
  [yes]      [no]
    │         │
    ▼         ▼
┌───────┐   (done)
│ Find  │
│ Target│ ← What block/code to execute?
└───┬───┘
    │
    ▼
┌─────────────────┐
│ Execution Type? │
└────────┬────────┘
         │
    ┌────┼────┬─────────┐
    ▼    ▼    ▼         ▼
┌─────┐┌─────┐┌─────┐┌─────┐
│Nav  ││SCL  ││Python││Tool │
│(go  ││Inter││Bridge││Call │
│to   ││preter│      │     │
│block││     ││      ││     │
└──┬──┘└──┬──┘└──┬───┘└──┬──┘
   │      │      │       │
   └──────┴──────┴───────┘
                 │
                 ▼
┌─────────────────┐
│ State Update    │ ← Variables, block states
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Output Router   │ ← Where do results go?
└────────┬────────┘
         │
    ┌────┴────┬─────────┐
    ▼         ▼         ▼
┌───────┐ ┌───────┐ ┌───────┐
│Display│ │Variable│ │Connect│
│(show  │ │(store  │ │(send  │
│text)  │ │value)  │ │to next│
└───────┘ └───────┘ └───────┘


3.4 Save/Load Flow


SAVE:
┌─────────────────┐
│ User: Save/🧮   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ State Collector │ ← Gather everything
└────────┬────────┘
         │
    ┌────┴────┬─────────┬─────────┐
    ▼         ▼         ▼         ▼
┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐
│Canvas │ │Content│ │Logic  │ │State  │
│Data   │ │Data   │ │Data   │ │Data   │
└───┬───┘ └───┬───┘ └───┬───┘ └───┬───┘
    │         │         │         │
    └────┬────┴─────────┴─────────┘
         │
         ▼
┌─────────────────┐
│ Serializer      │ ← Convert to .parti format
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ .parti File     │
└─────────────────┘




LOAD:
┌─────────────────┐
│ .parti File     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Deserializer    │ ← Parse .parti format
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Validator       │ ← Check integrity
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ State Loader    │ ← Populate all systems
└────────┬────────┘
         │
    ┌────┴────┬─────────┬─────────┐
    ▼         ▼         ▼         ▼
┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐
│Canvas │ │Content│ │Logic  │ │State  │
│System │ │System │ │System │ │System │
└───────┘ └───────┘ └───────┘ └───────┘
         │
         ▼
┌─────────────────┐
│ Render          │ ← Show it
└─────────────────┘


🦉 Section 4: SCL Interpreter


The heart of the execution system.


4.1 SCL Syntax Specification


Statement Structure:


[Order] [Type] [Modifier] [Operand] [Color]
   │       │       │          │        │
   │       │       │          │        └── State/mode (optional inline)
   │       │       │          └── What to operate on
   │       │       └── Direction/modifier (optional)
   │       └── Action verb
   └── Phase marker (optional)


Examples:


🐂📍 score 0          ← init: place variable "score" with value 0
🧲🪡 name             ← capture pull: get input into "name"
🦉 score > 10         ← parse: evaluate condition
🚀🛒 "Hello"          ← dispatch push: output "Hello"
🦋➕ score 1          ← iterate add: increment score by 1
🪵 2000               ← hold: pause for 2000ms


4.2 Core Operations


Variables (🐂📍 init place)


| Expression | Meaning |
|------------|---------|
| 🐂📍 x 0 | Create variable x, set to 0 |
| 🐂📍 name "Alex" | Create variable name, set to "Alex" |
| 🐂📍 active true | Create variable active, set to true |
| 🐂📍 items [] | Create variable items, set to empty list |


Input (🧲 capture)


| Expression | Meaning |
|------------|---------|
| 🧲🪡 name | Pull input from user into name |
| 🧲🪡 name "prompt" | Pull with prompt message |
| 🧲 blockRef | Capture reference to a block |


Output (🚀 dispatch)


| Expression | Meaning |
|------------|---------|
| 🚀🛒 "text" | Push text to display |
| 🚀🛒 variable | Push variable value to display |
| 🚀🛒🎯 blockRef "text" | Push text to specific block |


Logic (🦉 parse)


| Expression | Meaning |
|------------|---------|
| 🦉 x > 10 | Evaluate if x is greater than 10 |
| 🦉 name === "Alex" | Evaluate if name equals "Alex" |
| 🦉 active | Evaluate if active is truthy |
| 🦉 items 🥨 0 | Evaluate if items length > 0 (stretch/extend check) |


Math (➕➖)


| Expression | Meaning |
|------------|---------|
| ➕ x 1 | Add 1 to x |
| ➖ x 1 | Subtract 1 from x |
| 🦋➕ x 5 | Iterate: add 5 to x (same as ➕ but semantically "building") |


Control Flow


| Expression | Meaning |
|------------|---------|
| 🦉 condition ↳ | If condition true, execute indented block |
| ↳ | Else branch (after 🦉) |
| 🦋 items ↳ | For each item in items, execute block |
| 🦋 5 ↳ | Repeat 5 times |
| 🖼 | Return/exit current block |
| ⚫ | End/complete (no more statements) |


Navigation (🧸 channel/carry)


| Expression | Meaning |
|------------|---------|
| 🧸 🎯blockZip | Go to block with that zip |
| 🧸 ↑ | Go to connected block (up) |
| 🧸 ← | Go to connected block (left) |
| 🧸 🏠 | Go to home/main block |


Timing (🪵 hold, ⌛ temporitas)


| Expression | Meaning |
|------------|---------|
| 🪵 1000 | Pause for 1000ms |
| ⌛🦋 1000 ↳ | Every 1000ms, execute block |
| ⌛🪵 | Stop timer |


Tools (🤌 make/act)


| Expression | Meaning |
|------------|---------|
| 🤌 toolName inputs | Execute tool with inputs |
| 🤌🐋 "description" | AI: orchestrate/create tool from description |


4.3 Interpreter Architecture


┌─────────────────────────────────────────────────────────────┐
│                    SCL INTERPRETER                          │
│                                                             │
│  ┌─────────────────┐                                       │
│  │     Lexer       │ ← Break raw text into tokens          │
│  │  "🐂📍 x 0"     │                                       │
│  │      ↓          │                                       │
│  │  [🐂, 📍, x, 0] │                                       │
│  └────────┬────────┘                                       │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                       │
│  │     Parser      │ ← Build Abstract Syntax Tree          │
│  │                 │                                       │
│  │  {              │                                       │
│  │    type: "init",│                                       │
│  │    action: "place",                                     │
│  │    target: "x", │                                       │
│  │    value: 0     │                                       │
│  │  }              │                                       │
│  └────────┬────────┘                                       │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                       │
│  │   Validator     │ ← Check types, references exist       │
│  └────────┬────────┘                                       │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                       │
│  │   Executor      │ ← Actually do the thing               │
│  │                 │                                       │
│  │  state.set("x", 0)                                      │
│  └────────┬────────┘                                       │
│           │                                                 │
│           ▼                                                 │
│  ┌─────────────────┐                                       │
│  │ State Manager   │ ← Track all variables, block states   │
│  └─────────────────┘                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘


4.4 Emoji-to-Operation Mapping


const SCL_OPERATIONS = {
  // Orders (phase markers)
  "🐂": { phase: "init", operations: ["declare", "setup", "define"] },
  "⛽": { phase: "validate", operations: ["test", "check", "assert"] },
  "🦋": { phase: "iterate", operations: ["loop", "repeat", "build"] },
  "🏟": { phase: "execute", operations: ["run", "perform", "call"] },
  "🌾": { phase: "composite", operations: ["combine", "merge", "apply"] },
  "⚖": { phase: "calibrate", operations: ["adjust", "balance", "refine"] },
  "🖼": { phase: "complete", operations: ["return", "finish", "exit"] },
  
  // Types (action verbs)
  "🧲": { action: "capture", verb: ["get", "receive", "accept"] },
  "🚀": { action: "dispatch", verb: ["send", "emit", "output"] },
  "✒️": { action: "write", verb: ["record", "log", "document"] },
  "👀": { action: "inspect", verb: ["read", "examine", "query"] },
  "🦉": { action: "parse", verb: ["evaluate", "reason", "calculate"] },
  "📍": { action: "place", verb: ["set", "assign", "position"] },
  "🪵": { action: "hold", verb: ["pause", "wait", "retain"] },
  "🧸": { action: "channel", verb: ["goto", "navigate", "transfer"] },
  "🤌": { action: "make", verb: ["create", "act", "execute"] },
  "🐋": { action: "orchestrate", verb: ["lead", "conduct", "arrange"] },
  "🦢": { action: "compress", verb: ["fold", "merge", "nest"] },
  "🥨": { action: "extend", verb: ["stretch", "span", "reach"] },
  
  // Modifiers
  "🛒": { modifier: "push", direction: "out" },
  "🪡": { modifier: "pull", direction: "in" },
  "🍗": { modifier: "foundation", direction: "below" },
  "➕": { modifier: "add", operation: "increase" },
  "➖": { modifier: "subtract", operation: "decrease" },
  
  // Colors (state)
  "🟢": { state: "active" },
  "🟡": { state: "exploring" },
  "🔵": { state: "structured" },
  "🔴": { state: "urgent" },
  "⚫": { state: "complete" },
  "🟣": { state: "significant" },
  "🟠": { state: "connected" },
  "⚪": { state: "clear" }
}


4.5 Python Bridge


When SCL isn't enough, drop into Python:


┌─────────────────────────────────────────────────────────────┐
│                    PYTHON BRIDGE                            │
│                                                             │
│  SCL Context                      Python Runtime            │
│  ┌───────────┐                   ┌───────────────┐         │
│  │ Variables │ ───── 🧸🛒 ─────▶ │ Python Globals│         │
│  │ score: 10 │                   │ score = 10    │         │
│  │ name: "X" │                   │ name = "X"    │         │
│  └───────────┘                   └───────┬───────┘         │
│                                          │                  │
│                                          ▼                  │
│                                  ┌───────────────┐         │
│                                  │ Execute Code  │         │
│                                  │               │         │
│                                  │ result = ...  │         │
│                                  └───────┬───────┘         │
│                                          │                  │
│  ┌───────────┐                          │                  │
│  │ Variables │ ◀───── 🧲🪡 ─────────────┘                  │
│  │ result: ? │                                             │
│  └───────────┘                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘


Code Block Syntax:


┌─────────────────────────────────┐
│ 🐍 Python                       │
├─────────────────────────────────┤
│ import math                     │
│                                 │
│ # 🧲 pulls SCL variables in    │
│ radius = 🧲radius               │
│                                 │
│ # Do Python things              │
│ area = math.pi * radius ** 2   │
│                                 │
│ # 🚀 pushes results back       │
│ 🚀area                          │
└─────────────────────────────────┘


The 🧲 and 🚀 emojis inside Python are special markers the bridge recognizes.


📦 Section 5: The .parti File Format


The container that holds everything.


5.1 Format Overview


.parti is a structured format that contains:


.parti file
├── header (metadata)
├── config (project settings)
├── canvas (cells, strokes)
├── content (blocks, districts)
├── logic (connections, triggers)
├── state (variables, runtime state)
├── tools (embedded tools)
├── history (version traces)
└── assets (embedded media)


5.2 JSON Schema (v1 - Development)


{
  "$schema": "parti-v1",
  "header": {
    "version": "1.0",
    "created": "2026-01-31T12:00:00Z",
    "modified": "2026-01-31T14:30:00Z",
    "author": "username",
    "zip": "🐂🛒🐬🟡",
    "name": "Project Name",
    "description": "What this parti is"
  },
  
  "config": {
    "grid": {
      "cellSize": 48,
      "showGrid": true
    },
    "zipSystem": {
      "dialCount": 4,
      "dial1": {
        "name": "Phase",
        "options": ["🐂", "⛽", "🦋", "🏟", "🌾", "⚖", "🖼"]
      },
      "dial2": {
        "name": "Type", 
        "options": ["🧲", "🚀", "✒️", "👀", "🦉", "📍", "🪵", "🧸", "🤌", "🐋", "🦢", "🥨"]
      },
      "dial3": {
        "name": "Area",
        "options": ["🏛", "🔨", "🌹", "🪐", "⌛", "🐬"]
      },
      "colors": ["⚪", "🟡", "🟠", "🔴", "⚫", "🟣", "🔵", "🟢"]
    }
  },
  
  "canvas": {
    "viewport": {
      "x": 0,
      "y": 0,
      "zoom": 1.0
    },
    "cells": [
      {
        "x": 10,
        "y": 5,
        "content": "🐂",
        "style": {}
      }
    ],
    "strokes": [
      {
        "id": "stroke-001",
        "points": [{"x": 100.5, "y": 200.3}, {"x": 105.2, "y": 210.1}],
        "style": {"color": "#000000", "width": 2},
        "sheet": "default"
      }
    ]
  },
  
  "content": {
    "blocks": [
      {
        "id": "block-001",
        "type": "text",
        "position": {"x": 20, "y": 10},
        "size": {"width": 40, "height": 20},
        "zip": "🐂🧲🛒🟡",
        "content": {
          "text": "Hello world",
          "format": "plain"
        },
        "connections": ["conn-001"],
        "locked": false
      },
      {
        "id": "block-002",
        "type": "code",
        "position": {"x": 20, "y": 35},
        "size": {"width": 40, "height": 15},
        "zip": "🏟🤌🔨🟢",
        "content": {
          "language": "scl",
          "code": "🐂📍 count 0\n🦋 5 ↳\n  ➕ count 1\n🚀🛒 count"
        },
        "connections": [],
        "locked": false
      }
    ],
    "districts": [
      {
        "id": "district-001",
        "zip": "🏟💰🏛⚫",
        "bounds": {"x": 0, "y": 0, "width": 100, "height": 100},
        "contains": ["block-001", "block-002"],
        "locked": false
      }
    ]
  },
  
  "logic": {
    "connections": [
      {
        "id": "conn-001",
        "from": "block-001",
        "to": "block-002",
        "direction": "down",
        "trigger": {"type": "tap"},
        "condition": null
      }
    ],
    "triggers": [],
    "globalConditions": []
  },
  
  "state": {
    "variables": [
      {
        "name": "count",
        "value": 0,
        "type": "number",
        "scope": "global"
      }
    ],
    "blockStates": {},
    "activeBlock": null
  },
  
  "tools": [
    {
      "id": "tool-001",
      "name": "Counter",
      "zip": "🛠🧲➕🟢",
      "implementation": {
        "type": "scl",
        "code": "..."
      }
    }
  ],
  
  "history": {
    "traces": [
      {
        "id": "trace-001",
        "timestamp": "2026-01-31T12:00:00Z",
        "note": "Initial version",
        "snapshot": "..."
      }
    ],
    "currentTrace": "trace-001"
  },
  
  "assets": {
    "images": [],
    "fonts": [],
    "embedded": []
  }
}


5.3 Binary Format (v2 - Future)


When JSON becomes a performance bottleneck:


.parti binary structure:


┌──────────────────────────────────┐
│ Magic Number: "PARTI" (5 bytes)  │
├──────────────────────────────────┤
│ Version: uint16                  │
├──────────────────────────────────┤
│ Flags: uint32                    │
├──────────────────────────────────┤
│ Section Table Offset: uint64     │
├──────────────────────────────────┤
│ Section Table Count: uint32      │
├──────────────────────────────────┤
│                                  │
│         Section Data             │
│    (compressed, chunked)         │
│                                  │
├──────────────────────────────────┤
│                                  │
│         Section Table            │
│  [{type, offset, size, hash}]    │
│                                  │
└──────────────────────────────────┘


This is later. JSON first.


🌍 Section 6: Runtime Environments


Where Graph Parti runs.


6.1 Web Browser (Primary)


┌─────────────────────────────────────────────────────────────┐
│                       BROWSER                               │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Graph Parti App                     │   │
│  │                                                      │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐    │   │
│  │  │    UI      │  │   Canvas   │  │   State    │    │   │
│  │  │ (HTML/CSS) │  │  (Canvas   │  │ (JavaScript│    │   │
│  │  │            │  │   2D API)  │  │   Objects) │    │   │
│  │  └────────────┘  └────────────┘  └────────────┘    │   │
│  │                                                      │   │
│  │  ┌────────────────────────────────────────────┐    │   │
│  │  │              SCL Interpreter                │    │   │
│  │  │              (JavaScript)                   │    │   │
│  │  └────────────────────────────────────────────┘    │   │
│  │                                                      │   │
│  │  ┌────────────────────────────────────────────┐    │   │
│  │  │              Python Bridge                  │    │   │
│  │  │              (Pyodide/WASM)                 │    │   │
│  │  └────────────────────────────────────────────┘    │   │
│  │                                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Browser APIs                            │   │
│  │  File System Access, Clipboard, IndexedDB,          │   │
│  │  WebGL, WebGPU, Service Workers, etc.               │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘


Technologies:
- UI: HTML, CSS, vanilla JS or Svelte (lightweight)
- Canvas: Canvas 2D API (upgrade to WebGL/WebGPU later)
- State: JavaScript objects, IndexedDB for persistence
- SCL: JavaScript interpreter
- Python: Pyodide (Python compiled to WebAssembly)
- Files: File System Access API + IndexedDB fallback


6.2 Progressive Web App (PWA)


Same as browser, plus:


┌─────────────────────────────────────────────────────────────┐
│                         PWA                                 │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Service Worker                          │   │
│  │  - Offline support                                   │   │
│  │  - Background sync                                   │   │
│  │  - Push notifications                                │   │
│  │  - Cache management                                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Web App Manifest                        │   │
│  │  - Install to home screen                           │   │
│  │  - Standalone window                                │   │
│  │  - App icon                                         │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘


6.3 Desktop (Tauri - Future)


┌─────────────────────────────────────────────────────────────┐
│                    TAURI APP                                │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Web View (same app code)               │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Rust Backend                            │   │
│  │  - Native file system                               │   │
│  │  - System tray                                      │   │
│  │  - Native menus                                     │   │
│  │  - Performance-critical code                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘


Why Tauri over Electron:
- Much smaller bundle size (10MB vs 150MB)
- Uses system webview, not bundled Chromium
- Rust backend for performance
- Better security model


6.4 Mobile (PWA + Native Later)


Phase 1: PWA
- Works on iOS Safari, Android Chrome
- Add to home screen
- Offline capable
- Touch-optimized UI


Phase 2: Native (If Needed)
- iOS: Swift + WKWebView + shared core
- Android: Kotlin + WebView + shared core
- Native: file handling, sharing, performance


6.5 Environment Comparison


| Feature | Web | PWA | Tauri | Native Mobile |
|---------|-----|-----|-------|---------------|
| Offline | Partial | Yes | Yes | Yes |
| File System | Limited | Limited | Full | Full |
| Performance | Good | Good | Better | Best |
| Install | No | Yes | Yes | Yes |
| App Store | No | No | No | Yes |
| Bundle Size | 0 | 5MB | 10MB | ~20MB |
| Development | Easiest | Easy | Medium | Hard |


🪜 Section 7: Build Phases


How to build this incrementally.


Phase 🐂: Foundation (Current → +2 months)


Goal: Working canvas with content, basic .parti save/load


Build:
Canvas Layer
├── ✅ Grid rendering
├── ✅ Pan and zoom
├── ✅ Cell text input
├── ✅ Freehand drawing
├── ✅ Selection
├── 🔄 Block containers
└── 🔄 Basic .parti save/load (JSON)


Content Layer
├── ✅ Cell content
├── ✅ Stroke storage
├── 🔄 Block model
├── 🔄 Text blocks
└── 🔄 Paste detection


Milestone: Open Graph Parti → create content → save .parti → close → open .parti → content is there


Phase ⛽: Validation (+2-4 months)


Goal: Blocks connect, basic navigation works


Build:
Logic Layer (Basic)
├── Connections between blocks
├── Navigation (tap → go to block)
├── Full-screen block view
├── Back navigation
└── Simple triggers (tap only)


Zip System
├── Zip code data structure
├── Assign zip to block/district
├── Display zip codes
├── Basic zip queries
└── File naming with zips


Milestone: Create 3 blocks → connect them → tap through like an app


Phase 🦋: Iteration (+4-6 months)


Goal: SCL interpreter running, basic programming possible


Build:
SCL Interpreter
├── Lexer (text → tokens)
├── Parser (tokens → AST)
├── Core operations
│   ├── 🐂📍 (variable init)
│   ├── 🧲🪡 (input)
│   ├── 🚀🛒 (output)
│   ├── 🦉 (conditions)
│   ├── ➕➖ (math)
│   └── 🦋 (loops)
├── State manager
└── Error handling


Code Blocks
├── Code block type
├── SCL syntax highlighting
├── Run button
└── Output display


Milestone: Write 🐂📍 x 0 🦋 10 ↳ ➕ x 1 🚀🛒 x → see 1-10 printed


Phase 🏟: Execution (+6-9 months)


Goal: Full programming environment, tools work


Build:
Advanced SCL
├── All operations implemented
├── Block-scoped variables
├── Zip-scoped variables
├── Custom functions (🐂🔨)
├── Tool definitions
└── Error recovery


Python Bridge
├── Pyodide integration
├── SCL ↔ Python data transfer
├── Python code blocks
├── Library access
└── Sandboxing


Tool System
├── Tool model
├── Create tool from selection
├── Tool palette
├── Import/export tools
└── Tool sharing format


Milestone: Create a working calculator tool → save it → import into another .parti → it works


Phase 🌾: Integration (+9-12 months)


Goal: AI assistance, collaboration basics


Build:
AI Integration
├── AI context building (read .parti)
├── Natural language → SCL
├── Tool generation
├── Code explanation
└── Debugging assistance


Collaboration (Basic)
├── Export .parti
├── Import .parti
├── Manual merge
├── Conflict detection
└── Version diffing


Layer System
├── Traces (versions)
├── Ghost mode
├── Sheets (depth layers)
├── Pages (sequential)
└── Layer UI


Milestone: Ask "make me a tip calculator" → AI builds it → it works


Phase ⚖: Refinement (+12-18 months)


Goal: Performance, mobile polish, advanced features


Build:
Performance
├── Render optimization
├── Large file handling
├── Lazy loading
├── Memory management
└── Consider Rust/WASM for hot paths


Mobile
├── Touch optimization
├── Mobile-specific UI
├── PWA enhancement
├── Offline robustness
└── Share sheet integration


Advanced Features
├── Real-time collaboration
├── Cloud sync
├── Advanced zip routing
├── Procedural generation hooks
└── Plugin system


Milestone: 100k cells, 10k strokes, still smooth on phone


Phase 🖼: Completion (+18-24 months)


Goal: Production-ready, ecosystem established


Build:
Polish
├── Onboarding
├── Documentation
├── Tutorials (as .parti files!)
├── Error messages
└── Accessibility


Ecosystem
├── Tool library
├── Community sharing
├── Template library
├── Example projects
└── API for extensions


Platform
├── Consider native apps
├── Consider Tauri desktop
├── Consider team/enterprise features
└── Consider monetization


Milestone: Someone who's never coded creates and shares a working app


🧮 Section 8: Module Breakdown


Actual code organization.


8.1 Directory Structure


graph-parti/
├── index.html              ← Entry point
├── manifest.json           ← PWA manifest
├── sw.js                   ← Service worker
│
├── src/
│   ├── main.js             ← App initialization
│   │
│   ├── canvas/             ← Layer 1: Canvas
│   │   ├── Canvas.js       ← Main canvas class
│   │   ├── Grid.js         ← Grid rendering
│   │   ├── Viewport.js     ← Pan, zoom, coordinates
│   │   ├── Input.js        ← Touch, mouse, keyboard
│   │   └── Selection.js    ← Selection handling
│   │
│   ├── content/            ← Layer 2: Content
│   │   ├── Cell.js         ← Cell model
│   │   ├── Stroke.js       ← Stroke model
│   │   ├── Block.js        ← Block model
│   │   ├── District.js     ← District model
│   │   ├── TextBlock.js    ← Text block specifics
│   │   ├── CodeBlock.js    ← Code block specifics
│   │   └── ContentManager.js
│   │
│   ├── logic/              ← Layer 3: Logic
│   │   ├── ZipCode.js      ← Zip code model
│   │   ├── Connection.js   ← Connection model
│   │   ├── Trigger.js      ← Trigger model
│   │   ├── Condition.js    ← Condition model
│   │   ├── Router.js       ← Navigation routing
│   │   └── LogicManager.js
│   │
│   ├── execution/          ← Layer 4: Execution
│   │   ├── scl/
│   │   │   ├── Lexer.js    ← Tokenizer
│   │   │   ├── Parser.js   ← AST builder
│   │   │   ├── Interpreter.js ← Executor
│   │   │   ├── Operations.js ← Operation definitions
│   │   │   └── Errors.js   ← Error handling
│   │   ├── python/
│   │   │   ├── Bridge.js   ← Pyodide integration
│   │   │   └── Sandbox.js  ← Security
│   │   ├── State.js        ← Variable/state management
│   │   ├── Scheduler.js    ← Event queue
│   │   └── ExecutionManager.js
│   │
│   ├── collaboration/      ← Layer 5: AI + Collaboration
│   │   ├── ai/
│   │   │   ├── Context.js  ← Build context for AI
│   │   │   ├── Generate.js ← AI generation
│   │   │   └── Assist.js   ← AI assistance
│   │   ├── sync/
│   │   │   ├── Export.js   ← Export .parti
│   │   │   ├── Import.js   ← Import .parti
│   │   │   └── Merge.js    ← Merge versions
│   │   └── CollaborationManager.js
│   │
│   ├── tools/              ← Tool system
│   │   ├── Tool.js         ← Tool model
│   │   ├── ToolPalette.js  ← Tool UI
│   │   ├── ToolBuilder.js  ← Create tools
│   │   └── ToolLibrary.js  ← Built-in tools
│   │
│   ├── layers/             ← Layer architecture
│   │   ├── Trace.js        ← Version layers
│   │   ├── Sheet.js        ← Depth layers
│   │   ├── Page.js         ← Sequential layers
│   │   └── LayerManager.js
│   │
│   ├── file/               ← File handling
│   │   ├── PartiFormat.js  ← .parti serialization
│   │   ├── Validator.js    ← File validation
│   │   └── Migration.js    ← Version migration
│   │
│   ├── ui/                 ← User interface
│   │   ├── Palette.js      ← Artist palette
│   │   ├── Toolbar.js      ← Toolbar
│   │   ├── DialPicker.js   ← Zip dial UI
│   │   ├── Modals.js       ← Dialog boxes
│   │   └── Theme.js        ← Theming
│   │
│   └── utils/              ← Utilities
│       ├── Math.js         ← Math helpers
│       ├── Emoji.js        ← Emoji handling
│       ├── Events.js       ← Event system
│       └── Storage.js      ← IndexedDB wrapper
│
├── assets/
│   ├── icons/
│   └── fonts/
│
├── tests/
│   ├── scl/
│   ├── canvas/
│   └── integration/
│
└── docs/
    ├── SCL-SPEC.md         ← SCL language spec
    ├── PARTI-FORMAT.md     ← File format spec
    └── ARCHITECTURE.md     ← This document


8.2 Module Dependencies


┌──────────────────┐
                    │      main.js     │
                    └────────┬─────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│    Canvas     │   │      UI       │   │     File      │
└───────┬───────┘   └───────────────┘   └───────┬───────┘
        │                                       │
        ▼                                       │
┌───────────────┐                              │
│    Content    │ ◀────────────────────────────┘
└───────┬───────┘
        │
        ▼
┌───────────────┐
│     Logic     │
└───────┬───────┘
        │
        ▼
┌───────────────┐
│   Execution   │
└───────┬───────┘
        │
        ▼
┌───────────────┐
│ Collaboration │
└───────────────┘


Rule: Lower layers never import from higher layers. Data flows down via events.


🖼 Section 9: Summary


What You're Building


Graph Parti is:
- An infinite canvas (Layer 1)
- That holds content (Layer 2)
- Connected by logic (Layer 3)
- Executed by SCL and Python (Layer 4)
- Enhanced by AI and collaboration (Layer 5)
- Creating experiences (Layer 6)


The Key Innovations


1. SCL as visual programming language — emojis are the syntax
2. Zip codes as addresses AND logic — semantic compression becomes routing
3. .parti as universe container — one file holds everything
4. Mobile-first coding — no command line, no pinky-shift-ctrl
5. AI as co-creator — describe what you want, AI builds it


The Build Path


🐂 Foundation  →  Canvas + Content + Basic Save
⛽ Validation  →  Connections + Navigation + Zips
🦋 Iteration   →  SCL Interpreter + Code Blocks
🏟 Execution   →  Full SCL + Python + Tools
🌾 Integration →  AI + Collaboration + Layers
⚖ Refinement  →  Performance + Mobile + Polish
🖼 Completion  →  Production + Ecosystem


🐂 The Block Model 🔵


🦉 What This Document Covers


This is the complete specification for Blocks in Graph Parti. By the end, you'll understand:


1. What a Block is (and isn't)
2. Every Block type and its properties
3. How Blocks contain, connect, and execute
4. The data structures in detail
5. How to implement it in code


Blocks are the heart of Graph Parti. They're what turn a canvas into a programming environment.


🏛 Section 1: What Is a Block?


1.1 The Simple Definition


A Block is a bounded container on the canvas that holds content and can do things.


That last part is key: can do things. Cells and strokes are passive—they just exist. Blocks are active—they can respond to triggers, run code, navigate somewhere, transform data.


1.2 Block vs Cell vs Stroke


| Thing | What It Is | Can It Do Things? |
|-------|------------|-------------------|
| Cell | One character in one grid position | No. Passive display. |
| Stroke | A freehand line (array of points) | No. Passive display. |
| Block | A bounded region with content | Yes. Can execute, navigate, respond. |


1.3 The Container Metaphor


Think of Blocks like containers in the physical world:


| Physical Container | Block Equivalent |
|-------------------|------------------|
| A sticky note | Text Block |
| A form on a clipboard | Form Block |
| A spreadsheet printout | Table Block |
| A code snippet card | Code Block |
| A photo | Media Block |
| A calculator | Tool Block |
| A folder holding other things | Composite Block |


Each container has:
- A boundary (where it starts and ends)
- Content (what's inside)
- Behavior (what happens when you interact with it)


1.4 Blocks Are First-Class Citizens


In Graph Parti, Blocks are not just "things on the canvas." They're the primary unit of:


- Organization — Group related content
- Navigation — Go from Block to Block
- Execution — Run code within a Block
- Addressing — Zip codes attach to Blocks
- Sharing — Export/import Blocks as .parti snippets


🔢 Section 2: Block Types


Graph Parti has 8 Block types. Each serves a different purpose.


2.1 Type Overview


Block Types
├── 📝 Text Block      ← Formatted text, documents
├── 📊 Table Block     ← Rows and columns of data
├── 📋 Form Block      ← Interactive input fields
├── 💻 Code Block      ← SCL or Python code
├── 🖼 Media Block     ← Images, embedded files
├── 🛠 Tool Block      ← Executable tools/widgets
├── 📦 Composite Block ← Contains other Blocks
└── 🔗 Reference Block ← Points to another Block


2.2 📝 Text Block


Purpose: Hold formatted text. Documents, notes, long-form writing.


When created:
- Paste text from clipboard
- Import .md, .txt, .docx
- Create new text block manually


Content:
- Formatted text (markdown-style)
- Can have multiple pages
- Can have annotations (strokes on top)


Behavior:
- Double-click → Full-screen editor
- Can be navigated to (as a destination)
- Can trigger navigation (if connected)


Data Structure:


TextBlock {
  id: string
  type: "text"
  
  // Position & Size
  position: {x: int, y: int}        // Grid coordinates of top-left
  size: {width: int, height: int}   // Size in grid cells
  
  // Content
  content: {
    text: string                    // The actual text
    format: "plain" | "markdown"    // How to render
    pages: [                        // If paginated
      {number: int, content: string}
    ]
  }
  
  // Metadata
  zip: ZipCode | null
  locked: boolean
  created: datetime
  modified: datetime
  
  // Connections
  connections: [ConnectionId]       // Links to other blocks
  
  // Layers
  annotations: [Stroke]             // Drawings on top
}


2.3 📊 Table Block


Purpose: Hold structured data in rows and columns.


When created:
- Paste tabular data (TSV, CSV, markdown table)
- Create new table manually
- AI generates from description


Content:
- Rows and columns
- Headers
- Cell formatting
- Can have merged cells


Behavior:
- Click cell → Edit
- Can sort, filter (future)
- Can be data source for other Blocks


Data Structure:


TableBlock {
  id: string
  type: "table"
  
  position: {x: int, y: int}
  size: {width: int, height: int}
  
  content: {
    headers: [string]
    rows: [
      [CellValue]                   // Each row is array of cells
    ]
    columnWidths: [int]             // Width of each column
    rowHeights: [int]               // Height of each row
    mergedCells: [                  // Spans
      {row, col, rowSpan, colSpan}
    ]
  }
  
  zip: ZipCode | null
  locked: boolean
  connections: [ConnectionId]
}


CellValue {
  value: any
  type: "text" | "number" | "boolean" | "formula"
  format: {...}                     // Display formatting
}


2.4 📋 Form Block


Purpose: Interactive input fields. Collect data from user.


When created:
- Create new form manually
- AI generates from description
- Convert from sketch (future)


Content:
- Fields (text, number, dropdown, checkbox, etc.)
- Labels
- Validation rules
- Submit action


Behavior:
- User fills in fields
- On submit → triggers connected logic
- Can route based on answers


Data Structure:


FormBlock {
  id: string
  type: "form"
  
  position: {x: int, y: int}
  size: {width: int, height: int}
  
  content: {
    title: string
    fields: [FormField]
    submitLabel: string
    submitAction: Connection | SCLExpression
  }
  
  state: {
    values: {fieldId: value}        // Current form state
    errors: {fieldId: string}       // Validation errors
    submitted: boolean
  }
  
  zip: ZipCode | null
  locked: boolean
  connections: [ConnectionId]
}


FormField {
  id: string
  type: "text" | "number" | "textarea" | "dropdown" | 
        "radio" | "checkbox" | "date" | "slider" | "rating"
  label: string
  placeholder: string
  required: boolean
  default: any
  options: [any]                    // For dropdown, radio, checkbox
  validation: {
    min: number
    max: number
    pattern: string                 // Regex
    custom: SCLExpression
  }
}


2.5 💻 Code Block


Purpose: Hold and execute SCL or Python code.


When created:
- Create new code block manually
- AI generates code
- Paste code


Content:
- Code text
- Language (SCL or Python)
- Syntax highlighting


Behavior:
- Run → Executes code
- Output displays in block or connected block
- Can be triggered by connections


Data Structure:


CodeBlock {
  id: string
  type: "code"
  
  position: {x: int, y: int}
  size: {width: int, height: int}
  
  content: {
    language: "scl" | "python"
    code: string
    readonly: boolean               // Can user edit?
  }
  
  execution: {
    state: "idle" | "running" | "paused" | "error" | "complete"
    output: any                     // Last output
    error: string | null            // Last error
    lastRun: datetime
  }
  
  zip: ZipCode | null
  locked: boolean
  connections: [ConnectionId]
}


2.6 🖼 Media Block


Purpose: Hold images, videos, embedded files.


When created:
- Paste image
- Import file
- Drag and drop


Content:
- Media data (or reference to asset)
- Alt text
- Sizing mode


Behavior:
- Display media
- Can be annotated
- Can trigger on click


Data Structure:


MediaBlock {
  id: string
  type: "media"
  
  position: {x: int, y: int}
  size: {width: int, height: int}
  
  content: {
    mediaType: "image" | "video" | "audio" | "pdf" | "embed"
    source: {
      type: "data" | "url" | "asset"
      data: string                  // Base64 or URL or asset ID
    }
    alt: string
    fit: "contain" | "cover" | "fill" | "none"
  }
  
  annotations: [Stroke]
  
  zip: ZipCode | null
  locked: boolean
  connections: [ConnectionId]
}


2.7 🛠 Tool Block


Purpose: A working tool/widget. Calculator, dice roller, timer, etc.


When created:
- Create from Tool Library
- AI generates
- User builds and saves
- Import from shared .parti


Content:
- Tool definition (inputs, outputs, implementation)
- UI layout
- State


Behavior:
- Fully interactive
- Runs code internally
- Can connect to other Blocks


Data Structure:


ToolBlock {
  id: string
  type: "tool"
  
  position: {x: int, y: int}
  size: {width: int, height: int}
  
  tool: {
    name: string
    icon: Emoji
    description: string
    
    inputs: [ToolInput]
    outputs: [ToolOutput]
    
    implementation: {
      type: "scl" | "python" | "hybrid"
      code: string
    }
    
    ui: {
      layout: "vertical" | "horizontal" | "grid" | "custom"
      elements: [UIElement]         // Buttons, displays, inputs
    }
  }
  
  state: {
    inputValues: {inputId: value}
    outputValues: {outputId: value}
    internalState: {...}            // Tool-specific state
  }
  
  zip: ZipCode | null
  locked: boolean
  connections: [ConnectionId]
}


ToolInput {
  id: string
  name: string
  type: "number" | "string" | "boolean" | "any"
  default: any
}


ToolOutput {
  id: string
  name: string
  type: "number" | "string" | "boolean" | "any"
}


UIElement {
  type: "button" | "display" | "input" | "slider" | "label"
  id: string
  properties: {...}                 // Type-specific
  action: SCLExpression | null      // What happens on interact
}


2.8 📦 Composite Block


Purpose: Contains other Blocks. A Block of Blocks.


When created:
- Group selected Blocks
- Create intentionally as container
- District becomes Composite when needed


Content:
- Child Blocks
- Internal layout
- Internal connections


Behavior:
- Can collapse/expand
- Children can execute independently
- Can expose inputs/outputs from children


Data Structure:


CompositeBlock {
  id: string
  type: "composite"
  
  position: {x: int, y: int}
  size: {width: int, height: int}
  
  content: {
    children: [Block]               // Nested Blocks
    internalConnections: [Connection]
    layout: "free" | "stack" | "grid"
  }
  
  interface: {
    exposedInputs: [                // Inputs from children made available
      {childId, inputId, alias}
    ]
    exposedOutputs: [               // Outputs from children made available
      {childId, outputId, alias}
    ]
  }
  
  display: {
    collapsed: boolean
    collapsedLabel: string
    collapsedIcon: Emoji
  }
  
  zip: ZipCode | null
  locked: boolean
  connections: [ConnectionId]
}


2.9 🔗 Reference Block


Purpose: Points to another Block. Like a symlink or shortcut.


When created:
- Create reference to existing Block
- Useful for showing same content in multiple places


Content:
- Reference to target Block


Behavior:
- Displays target's content
- Changes sync to target
- Can have its own position/size


Data Structure:


ReferenceBlock {
  id: string
  type: "reference"
  
  position: {x: int, y: int}
  size: {width: int, height: int}   // Can differ from target
  
  reference: {
    targetId: string                // Block being referenced
    targetZip: ZipCode | null       // Or reference by zip
    syncSize: boolean               // Match target's size?
  }
  
  display: {
    showIndicator: boolean          // Show "this is a reference" badge
    opacity: float                  // Can dim references
  }
  
  zip: ZipCode | null               // Reference can have its own zip
  locked: boolean
  connections: [ConnectionId]       // Reference can have its own connections
}


🧲 Section 3: Block Properties


All Blocks share certain properties. Let's define them precisely.


3.1 The Base Block


Every Block type extends this base:


BaseBlock {
  // Identity
  id: string                        // Unique identifier (UUID)
  type: BlockType                   // Which kind of Block
  
  // Position & Size
  position: {
    x: int                          // Grid column (left edge)
    y: int                          // Grid row (top edge)
  }
  size: {
    width: int                      // Width in grid cells
    height: int                     // Height in grid cells
  }
  
  // Addressing
  zip: ZipCode | null               // Semantic address
  
  // State
  locked: boolean                   // Can it be edited?
  visible: boolean                  // Is it rendered?
  
  // Metadata
  created: datetime
  modified: datetime
  author: string | null
  
  // Connections
  connections: [ConnectionId]       // Outgoing connections
  
  // Layers (optional)
  sheet: SheetId | null             // Which depth layer
  annotations: [Stroke]             // Drawings on top of block
}


3.2 Position and Size


Blocks live on the grid. Their position is the top-left cell. Their size is in cells.


Grid:
    0   1   2   3   4   5   6   7   8   9
  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
0 │   │   │   │   │   │   │   │   │   │   │
  ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤
1 │   │   │ ╔═══════════════╗ │   │   │   │
  ├───┼───┼─║───┼───┼───┼───║─┼───┼───┼───┤
2 │   │   │ ║   Block       ║ │   │   │   │
  ├───┼───┼─║   position:   ║─┼───┼───┼───┤
3 │   │   │ ║   {x:2, y:1}  ║ │   │   │   │
  ├───┼───┼─║   size:       ║─┼───┼───┼───┤
4 │   │   │ ║   {w:4, h:4}  ║ │   │   │   │
  ├───┼───┼─╚═══════════════╝─┼───┼───┼───┤
5 │   │   │   │   │   │   │   │   │   │   │
  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘


Rules:


- Blocks snap to grid (position is always integers)
- Blocks can overlap (z-order determined by creation time or explicit layer)
- Minimum size: 1x1 cell
- Maximum size: no limit


3.3 The Zip Address


Every Block can have a Zip code. This is how you address it.


ZipCode {
  dial1: Emoji | null               // First dial (user-defined meaning)
  dial2: Emoji | null               // Second dial
  dial3: Emoji | null               // Third dial
  color: Emoji                      // Required: state/status (one of 8)
  
  raw: string                       // Full string: "🐂🧲🛒🟡"
}


Zip enables:


- Finding blocks: "Show me all 🔴 blocks"
- Navigation: "Go to 🐂🧲🛒🟡"
- Routing: "If answer is X, go to 🔴 block"
- Grouping: All blocks with same zip are related


3.4 Locked State


When locked: true:


- Content cannot be edited
- Block cannot be moved
- Block cannot be resized
- Block cannot be deleted
- Connections can still trigger
- Code can still execute


Use cases:
- Published/final content
- Template blocks
- System blocks


3.5 Connections


Connections link Blocks together. A Block stores IDs of its outgoing connections.


Connection {
  id: string
  
  from: {
    blockId: string
    port: "center" | "top" | "bottom" | "left" | "right"
  }
  
  to: {
    blockId: string | null          // null if going to zip
    zip: ZipCode | null             // Can target by zip instead
    port: "center" | "top" | "bottom" | "left" | "right"
  }
  
  trigger: Trigger
  condition: Condition | null
  
  style: {
    visible: boolean                // Show the line?
    lineStyle: "solid" | "dashed" | "arrow"
    color: string
  }
}


We'll cover connections in detail in Section 5.


🫀 Section 4: Block Lifecycle


How Blocks are created, modified, and destroyed.


4.1 Creation


Blocks can be created by:


| Action | Result |
|--------|--------|
| Paste text | → Text Block |
| Paste table data | → Table Block |
| Paste image | → Media Block |
| Paste code | → Code Block (if detected) or Text Block |
| Create from toolbar | → Empty Block of chosen type |
| AI generation | → Block of appropriate type |
| Import .parti | → Composite Block (or individual) |
| Group selection | → Composite Block |
| Tool from library | → Tool Block |


Creation Flow:


User Action
    │
    ▼
┌─────────────────┐
│ Detect Type     │ ← What kind of content is this?
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Create Block    │ ← Instantiate with defaults
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Position Block  │ ← Where on canvas?
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Parse Content   │ ← Process the content for this type
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Register Block  │ ← Add to content system
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Render Block    │ ← Draw on canvas
└─────────────────┘


4.2 Modification


Blocks can be modified:


| Change | How |
|--------|-----|
| Move | Drag to new position |
| Resize | Drag edges/corners |
| Edit content | Double-click, then edit |
| Change zip | Dial picker |
| Connect | Draw connection line |
| Lock/unlock | Toggle in context menu |


Modification Flow:


User Edit
    │
    ▼
┌─────────────────┐
│ Validate Edit   │ ← Is this allowed? (locked?)
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Update Block    │ ← Modify in memory
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Mark Modified   │ ← Update timestamp
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Notify Change   │ ← Tell other systems
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Re-render       │ ← Update display
└─────────────────┘


4.3 Destruction


Blocks can be destroyed by:


| Action | Result |
|--------|--------|
| Delete key | Removes block |
| Cut | Removes block, copies to clipboard |
| Undo past creation | Removes block |


Destruction Flow:


Delete Request
    │
    ▼
┌─────────────────┐
│ Check Locked    │ ← Can't delete locked blocks
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Remove Connections │ ← Disconnect from other blocks
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Remove from District │ ← If in a district
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Unregister Block │ ← Remove from content system
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Add to Undo Stack │ ← So we can restore
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Re-render Canvas │ ← Block disappears
└─────────────────┘


4.4 State Transitions


Blocks can be in different states:


┌──────────────┐
            │   Created    │
            └──────┬───────┘
                   │
                   ▼
            ┌──────────────┐
     ┌─────▶│    Idle      │◀─────┐
     │      └──────┬───────┘      │
     │             │              │
     │      (trigger fires)       │
     │             │              │
     │             ▼              │
     │      ┌──────────────┐      │
     │      │   Executing  │      │
     │      └──────┬───────┘      │
     │             │              │
     │    ┌────────┼────────┐     │
     │    ▼        ▼        ▼     │
     │ ┌──────┐ ┌──────┐ ┌──────┐ │
     │ │Complete│Error │Paused│ │
     │ └───┬──┘ └───┬──┘ └───┬──┘ │
     │     │        │        │    │
     └─────┴────────┴────────┴────┘
     
     
            ┌──────────────┐
            │   Locked     │ ← Can still execute, can't edit
            └──────────────┘
            
            ┌──────────────┐
            │   Hidden     │ ← Not rendered, still exists
            └──────────────┘
            
            ┌──────────────┐
            │   Deleted    │ ← In undo stack, not in canvas
            └──────────────┘


🔗 Section 5: Block Connections


How Blocks link to each other.


5.1 What Is a Connection?


A Connection is a directed link from one Block to another. It defines:


- From: Which Block, which edge
- To: Which Block (or Zip), which edge
- Trigger: What causes the connection to activate
- Condition: Optional filter for when it activates
- Action: What happens when it activates (usually navigation or execution)


5.2 Connection Anatomy


┌─────────────┐                     ┌─────────────┐
│             │                     │             │
│   Block A   │────── Connection ──▶│   Block B   │
│             │       (tap)         │             │
└─────────────┘                     └─────────────┘


Connection:
  from: {blockId: "A", port: "right"}
  to: {blockId: "B", port: "left"}
  trigger: {type: "tap"}
  condition: null
  action: {type: "navigate"}


5.3 Ports


Blocks have 5 ports (connection points):


top
               │
        ┌──────┴──────┐
        │             │
  left ─┤   center    ├─ right
        │             │
        └──────┬──────┘
               │
             bottom


Port usage:


| Port | Typical Use |
|------|-------------|
| center | General purpose, tool connections |
| top | "Previous" in sequence, "back" |
| bottom | "Next" in sequence, "forward" |
| left | "Alternative", sidebar |
| right | "Details", actions |


This maps to the navigation model:


↑
        ┌─────┴─────┐
        │           │
    ←  ─┤    🏠     ├─  →
        │           │
        └─────┬─────┘
              ↓


5.4 Triggers


What causes a connection to activate:


Trigger {
  type: TriggerType
  config: {...}                     // Type-specific config
}


TriggerType:
  "tap"      → User taps/clicks the block
  "swipe"    → User swipes in a direction
  "hover"    → User hovers for duration (desktop)
  "load"     → Block becomes visible/active
  "timer"    → After delay or on interval
  "value"    → Variable changes to match condition
  "submit"   → Form is submitted
  "complete" → Code finishes executing
  "custom"   → SCL expression evaluates true


Trigger configs:


// Tap - no config needed
{type: "tap"}


// Swipe - which direction
{type: "swipe", config: {direction: "left" | "right" | "up" | "down"}}


// Hover - how long
{type: "hover", config: {duration: 500}}  // ms


// Load - no config
{type: "load"}


// Timer - delay and repeat
{type: "timer", config: {delay: 1000, repeat: false}}
{type: "timer", config: {delay: 0, repeat: true, interval: 1000}}


// Value - watch a variable
{type: "value", config: {variable: "score", comparison: ">", threshold: 10}}


// Submit - watch a form
{type: "submit", config: {formId: "block-123"}}


// Complete - watch code block
{type: "complete", config: {codeBlockId: "block-456"}}


// Custom - SCL expression
{type: "custom", config: {expression: "🦉 lives > 0"}}


5.5 Conditions


Optional filter on when connection activates:


Condition {
  type: "simple" | "compound"
  
  // For simple:
  expression: SCLExpression          // "🦉 score > 10"
  
  // For compound:
  operator: "and" | "or"
  children: [Condition]
}


Examples:


// Simple: score must be over 10
{type: "simple", expression: "🦉 score > 10"}


// Compound: score over 10 AND lives > 0
{
  type: "compound",
  operator: "and",
  children: [
    {type: "simple", expression: "🦉 score > 10"},
    {type: "simple", expression: "🦉 lives > 0"}
  ]
}


5.6 Actions


What happens when connection activates:


Action {
  type: ActionType
  config: {...}
}


ActionType:
  "navigate"  → Go to target block (full-screen or scroll-to)
  "execute"   → Run target block's code
  "show"      → Make target visible
  "hide"      → Make target invisible
  "toggle"    → Toggle target visibility
  "set"       → Set a variable
  "call"      → Call a tool
  "custom"    → Run SCL expression


Action configs:


// Navigate - go to block
{type: "navigate", config: {mode: "fullscreen" | "scroll" | "warp"}}


// Execute - run code
{type: "execute", config: {await: true | false}}


// Show/Hide/Toggle - visibility
{type: "show"}
{type: "hide"}
{type: "toggle"}


// Set - change variable
{type: "set", config: {variable: "score", value: 0}}
{type: "set", config: {variable: "score", expression: "➕ score 1"}}


// Call - invoke tool
{type: "call", config: {toolId: "tool-123", inputs: {...}}}


// Custom - any SCL
{type: "custom", config: {expression: "🚀🛒 'Hello!'"}}


5.7 Connection Examples


Example 1: Simple navigation


Tap Block A → Go to Block B


{
  id: "conn-001",
  from: {blockId: "block-a", port: "right"},
  to: {blockId: "block-b", port: "left"},
  trigger: {type: "tap"},
  condition: null,
  action: {type: "navigate", config: {mode: "fullscreen"}}
}


Example 2: Conditional navigation


Tap Block A → If score > 10, go to Win Block, else go to Lose Block


// Connection 1: A → Win (if score > 10)
{
  id: "conn-002",
  from: {blockId: "block-a", port: "right"},
  to: {blockId: "win-block", port: "left"},
  trigger: {type: "tap"},
  condition: {type: "simple", expression: "🦉 score > 10"},
  action: {type: "navigate", config: {mode: "fullscreen"}}
}


// Connection 2: A → Lose (if score 
  }
  
  // Block-local state
  locals: {
    variables: Map
  }
  
  // Input values (if triggered with inputs)
  inputs: Map
  
  // Output channel
  output: {
    display: (value) => void        // Show in output area
    set: (name, value) => void      // Set variable
    navigate: (target) => void      // Go to block
    call: (toolId, inputs) => any   // Call tool
  }
  
  // Canvas access (read-only mostly)
  canvas: {
    getBlock: (id) => Block
    getBlockByZip: (zip) => Block[]
    getVariable: (name) => any
  }
}


6.3 Execution Flow


Trigger Fires
    │
    ▼
┌─────────────────┐
│ Find Connection │ ← Which connection was triggered?
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Check Condition │ ← Should this activate?
└────────┬────────┘
         │
    ┌────┴────┐
    ▼         ▼
  [yes]      [no]
    │         │
    │         ▼
    │      (stop)
    │
    ▼
┌─────────────────┐
│ Get Action      │ ← What should happen?
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Get Target      │ ← Which block?
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Build Context   │ ← Prepare execution environment
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Execute Action  │ ← Do the thing
└────────┬────────┘
         │
    ┌────┴────┬────────┐
    ▼         ▼        ▼
Navigate   Execute   Other
    │         │        │
    ▼         ▼        ▼
┌───────┐ ┌───────┐ ┌───────┐
│Go to  │ │Run    │ │Set,   │
│block  │ │code   │ │show,  │
│       │ │       │ │hide...│
└───────┘ └───────┘ └───────┘


6.4 Code Block Execution


When a Code Block runs:


Code Block Triggered
    │
    ▼
┌─────────────────┐
│ Get Code        │ ← The SCL or Python text
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Check Language  │
└────────┬────────┘
         │
    ┌────┴────┐
    ▼         ▼
  [SCL]    [Python]
    │         │
    ▼         ▼
┌───────┐ ┌───────┐
│ SCL   │ │Python │
│Interp │ │Bridge │
└───┬───┘ └───┬───┘
    │         │
    └────┬────┘
         │
         ▼
┌─────────────────┐
│ Handle Output   │ ← Display, set variables, etc.
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Update State    │ ← Block state: complete/error
└─────────────────┘


6.5 Tool Block Execution


When a Tool Block runs:


Tool Interaction (button press, input change, etc.)
    │
    ▼
┌─────────────────┐
│ Get UI Event    │ ← Which element, what action?
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Find Handler    │ ← What SCL handles this?
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Gather Inputs   │ ← Get current input values
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Execute Handler │ ← Run the SCL
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Update Outputs  │ ← Set output values
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Update UI       │ ← Reflect new state
└─────────────────┘


🖼 Section 7: Block Rendering


How Blocks appear on canvas.


7.1 Render Layers


Each Block renders in layers:


┌─────────────────────────────────┐
│         Annotations             │ ← Strokes drawn on top
├─────────────────────────────────┤
│         UI Elements             │ ← Buttons, inputs (for tools)
├─────────────────────────────────┤
│         Content                 │ ← Text, table, image, code
├─────────────────────────────────┤
│         Background              │ ← Fill color, border
├─────────────────────────────────┤
│         Shadow/Effects          │ ← Drop shadow, glow
└─────────────────────────────────┘


7.2 Visual States


Blocks look different based on state:


| State | Visual Indicator |
|-------|-----------------|
| Normal | Default appearance |
| Selected | Highlight border, handles visible |
| Hovered | Subtle highlight |
| Locked | Lock icon, slightly dimmed |
| Executing | Pulse animation, activity indicator |
| Error | Red border, error icon |
| Connected (from) | Outgoing connection lines visible |
| Connected (to) | Port highlights when source hovered |


7.3 Zoom Behavior


Blocks change appearance at different zoom levels:


| Zoom Level | What Shows |
|------------|------------|
| Very far | Just colored rectangle + zip emoji |
| Far | Rectangle + title + zip |
| Medium | Full content, normal rendering |
| Close | Full content + details + controls |
| Very close | Full fidelity, editing UI |


7.4 Type-Specific Rendering


Text Block:
┌─────────────────────────────────┐
│ 📝 Document Title          🔒  │ ← Header with type icon, lock
├─────────────────────────────────┤
│                                 │
│  Formatted text content here    │
│  with markdown rendering...     │
│                                 │
├─────────────────────────────────┤
│ 🐂🧲🛒🟡            Page 1/5   │ ← Footer with zip, page nav
└─────────────────────────────────┘


Code Block:
┌─────────────────────────────────┐
│ 💻 SCL                    ▶ Run │ ← Header with language, run button
├─────────────────────────────────┤
│  1 │ 🐂📍 count 0               │
│  2 │ 🦋 5 ↳                     │
│  3 │   ➕ count 1               │
│  4 │ 🚀🛒 count                 │
├─────────────────────────────────┤
│ Output: 5                       │ ← Output area
├─────────────────────────────────┤
│ 🏟🤌🔨🟢                        │ ← Zip
└─────────────────────────────────┘


Tool Block:
┌─────────────────────────────────┐
│ 🛠 Calculator              🔧  │ ← Header with name, settings
├─────────────────────────────────┤
│  ┌─────────────────────────┐   │
│  │                     128 │   │ ← Display
│  └─────────────────────────┘   │
│  ┌───┬───┬───┬───┐             │
│  │ 7 │ 8 │ 9 │ ÷ │             │ ← Buttons
│  ├───┼───┼───┼───┤             │
│  │ 4 │ 5 │ 6 │ × │             │
│  ├───┼───┼───┼───┤             │
│  │ 1 │ 2 │ 3 │ - │             │
│  ├───┼───┼───┼───┤             │
│  │ 0 │ . │ = │ + │             │
│  └───┴───┴───┴───┘             │
├─────────────────────────────────┤
│ 🛠🧲➕🟢                        │
└─────────────────────────────────┘


Form Block:
┌─────────────────────────────────┐
│ 📋 Feedback Form                │
├─────────────────────────────────┤
│                                 │
│  Name: __ │
│                                 │
│  Email: _ │
│                                 │
│  Rating: ★ ★ ★ ★ ☆            │
│                                 │
│  Priority:  ○ 🟢  ○ 🟡  ● 🔴   │
│                                 │
│       ┌──────────────────┐      │
│       │      Submit      │      │
│       └──────────────────┘      │
├─────────────────────────────────┤
│ 📋🧲🪡🟡                        │
└─────────────────────────────────┘


💻 Section 8: Implementation


The actual code structure.


8.1 Base Block Class


// src/content/Block.js


class Block {
  constructor(config) {
    // 🐂📍 — init: place identity
    this.id = config.id || generateId()
    this.type = config.type
    
    // 🐂📍 — init: place position
    this.position = {
      x: config.position?.x || 0,
      y: config.position?.y || 0
    }
    this.size = {
      width: config.size?.width || 10,
      height: config.size?.height || 5
    }
    
    // 🐂📍 — init: place metadata
    this.zip = config.zip || null
    this.locked = config.locked || false
    this.visible = config.visible !== false
    this.created = config.created || new Date()
    this.modified = config.modified || new Date()
    
    // 🐂📍 — init: place connections
    this.connections = config.connections || []
    
    // 🐂📍 — init: place layers
    this.sheet = config.sheet || null
    this.annotations = config.annotations || []
  }
  
  // 👀 — inspect: get bounds
  getBounds() {
    return {
      x: this.position.x,
      y: this.position.y,
      width: this.size.width,
      height: this.size.height,
      right: this.position.x + this.size.width,
      bottom: this.position.y + this.size.height
    }
  }
  
  // 🦉 — parse: check if point is inside
  containsPoint(x, y) {
    const bounds = this.getBounds()
    return x >= bounds.x && 
           x = bounds.y && 
           y  -1) {
      this.connections.splice(index, 1)
      this.modified = new Date()
    }
  }
  
  // 🚀🛒 — dispatch: serialize for save
  serialize() {
    return {
      id: this.id,
      type: this.type,
      position: {...this.position},
      size: {...this.size},
      zip: this.zip?.raw || null,
      locked: this.locked,
      visible: this.visible,
      created: this.created.toISOString(),
      modified: this.modified.toISOString(),
      connections: [...this.connections],
      sheet: this.sheet,
      annotations: this.annotations.map(s => s.serialize())
    }
  }
  
  // 🌹 — render: draw the block (override in subclasses)
  render(ctx, viewport) {
    throw new Error('Subclass must implement render()')
  }
  
  // 🏟 — execute: run the block (override if executable)
  execute(context) {
    // Default: blocks don't execute
    return null
  }
  
  // ⛽ — validate: check if block is valid
  validate() {
    const errors = []
    if (!this.id) errors.push('Missing id')
    if (!this.type) errors.push('Missing type')
    if (this.size.width = 1')
    if (this.size.height = 1')
    return {valid: errors.length === 0, errors}
  }
}


8.2 Text Block


// src/content/TextBlock.js


class TextBlock extends Block {
  constructor(config) {
    super({...config, type: 'text'})
    
    // 🐂📍 — init: text-specific content
    this.content = {
      text: config.content?.text || '',
      format: config.content?.format || 'plain',
      pages: config.content?.pages || null
    }
  }
  
  // 📍 — place: set text
  setText(text) {
    if (this.locked) return false
    this.content.text = text
    this.modified = new Date()
    return true
  }
  
  // 👀 — inspect: get text
  getText() {
    return this.content.text
  }
  
  // 👀 — inspect: get page count
  getPageCount() {
    if (!this.content.pages) return 1
    return this.content.pages.length
  }
  
  // 🚀🛒 — dispatch: serialize
  serialize() {
    return {
      ...super.serialize(),
      content: {
        text: this.content.text,
        format: this.content.format,
        pages: this.content.pages
      }
    }
  }
  
  // 🌹 — render
  render(ctx, viewport) {
    const bounds = this.getBounds()
    const screenBounds = viewport.gridToScreen(bounds)
    
    // 🌹 — render: background
    ctx.fillStyle = '#ffffff'
    ctx.fillRect(
      screenBounds.x, 
      screenBounds.y, 
      screenBounds.width, 
      screenBounds.height
    )
    
    // 🌹 — render: border
    ctx.strokeStyle = this.locked ? '#999999' : '#333333'
    ctx.lineWidth = 2
    ctx.strokeRect(
      screenBounds.x, 
      screenBounds.y, 
      screenBounds.width, 
      screenBounds.height
    )
    
    // 🌹 — render: header
    const headerHeight = 24
    ctx.fillStyle = '#f0f0f0'
    ctx.fillRect(
      screenBounds.x, 
      screenBounds.y, 
      screenBounds.width, 
      headerHeight
    )
    
    // 🌹 — render: type icon
    ctx.font = '16px sans-serif'
    ctx.fillStyle = '#333333'
    ctx.fillText('📝', screenBounds.x + 4, screenBounds.y + 18)
    
    // 🌹 — render: text content
    ctx.font = '14px sans-serif'
    ctx.fillStyle = '#000000'
    const textX = screenBounds.x + 8
    const textY = screenBounds.y + headerHeight + 20
    
    // Simple text wrapping (basic implementation)
    const words = this.content.text.split(' ')
    let line = ''
    let y = textY
    const lineHeight = 18
    const maxWidth = screenBounds.width - 16
    
    for (const word of words) {
      const testLine = line + word + ' '
      const metrics = ctx.measureText(testLine)
      if (metrics.width > maxWidth && line !== '') {
        ctx.fillText(line, textX, y)
        line = word + ' '
        y += lineHeight
        if (y > screenBounds.y + screenBounds.height - 30) break
      } else {
        line = testLine
      }
    }
    ctx.fillText(line, textX, y)
    
    // 🌹 — render: zip code (if present)
    if (this.zip) {
      ctx.font = '12px sans-serif'
      ctx.fillText(
        this.zip.raw, 
        screenBounds.x + 4, 
        screenBounds.y + screenBounds.height - 8
      )
    }
  }
  
  // 🧲🪡 — capture: create from pasted text
  static fromPaste(text, position) {
    // 🦉 — parse: detect if markdown
    const isMarkdown = text.includes('#') || 
                       text.includes('**') || 
                       text.includes('- ')
    
    // 🦉 — parse: estimate size based on content
    const lines = text.split('\n')
    const maxLineLength = Math.max(...lines.map(l => l.length))
    const width = Math.min(Math.max(Math.ceil(maxLineLength / 4), 10), 60)
    const height = Math.min(Math.max(lines.length + 4, 5), 40)
    
    return new TextBlock({
      position,
      size: {width, height},
      content: {
        text,
        format: isMarkdown ? 'markdown' : 'plain'
      }
    })
  }
}


8.3 Code Block


// src/content/CodeBlock.js


class CodeBlock extends Block {
  constructor(config) {
    super({...config, type: 'code'})
    
    // 🐂📍 — init: code-specific content
    this.content = {
      language: config.content?.language || 'scl',
      code: config.content?.code || '',
      readonly: config.content?.readonly || false
    }
    
    // 🐂📍 — init: execution state
    this.execution = {
      state: 'idle',      // idle | running | paused | error | complete
      output: null,
      error: null,
      lastRun: null
    }
  }
  
  // 📍 — place: set code
  setCode(code) {
    if (this.locked || this.content.readonly) return false
    this.content.code = code
    this.modified = new Date()
    return true
  }
  
  // 👀 — inspect: get code
  getCode() {
    return this.content.code
  }
  
  // 🏟 — execute: run the code
  async execute(context) {
    // 🐂 — init execution
    this.execution.state = 'running'
    this.execution.output = null
    this.execution.error = null
    this.execution.lastRun = new Date()
    
    try {
      let result
      
      if (this.content.language === 'scl') {
        // 🏟🦉 — execute SCL via interpreter
        result = await context.sclInterpreter.run(
          this.content.code,
          context
        )
      } else if (this.content.language === 'python') {
        // 🏟🐍 — execute Python via bridge
        result = await context.pythonBridge.run(
          this.content.code,
          context
        )
      }
      
      // 🖼 — complete
      this.execution.state = 'complete'
      this.execution.output = result
      return result
      
    } catch (error) {
      // 🔴 — error
      this.execution.state = 'error'
      this.execution.error = error.message
      throw error
    }
  }
  
  // 🚀🛒 — dispatch: serialize
  serialize() {
    return {
      ...super.serialize(),
      content: {
        language: this.content.language,
        code: this.content.code,
        readonly: this.content.readonly
      },
      execution: {
        state: this.execution.state,
        output: this.execution.output,
        error: this.execution.error,
        lastRun: this.execution.lastRun?.toISOString()
      }
    }
  }
  
  // 🌹 — render
  render(ctx, viewport) {
    const bounds = this.getBounds()
    const screenBounds = viewport.gridToScreen(bounds)
    
    // 🌹 — render: background (dark for code)
    ctx.fillStyle = '#1e1e1e'
    ctx.fillRect(
      screenBounds.x, 
      screenBounds.y, 
      screenBounds.width, 
      screenBounds.height
    )
    
    // 🌹 — render: border based on state
    const borderColors = {
      idle: '#444444',
      running: '#4488ff',
      complete: '#44aa44',
      error: '#ff4444',
      paused: '#ffaa00'
    }
    ctx.strokeStyle = borderColors[this.execution.state]
    ctx.lineWidth = 2
    ctx.strokeRect(
      screenBounds.x, 
      screenBounds.y, 
      screenBounds.width, 
      screenBounds.height
    )
    
    // 🌹 — render: header
    const headerHeight = 28
    ctx.fillStyle = '#2d2d2d'
    ctx.fillRect(
      screenBounds.x, 
      screenBounds.y, 
      screenBounds.width, 
      headerHeight
    )
    
    // 🌹 — render: language indicator
    ctx.font = '14px monospace'
    ctx.fillStyle = '#888888'
    const langIcon = this.content.language === 'scl' ? '💻' : '🐍'
    const langText = this.content.language.toUpperCase()
    ctx.fillText(
      ${langIcon} ${langText}, 
      screenBounds.x + 8, 
      screenBounds.y + 19
    )
    
    // 🌹 — render: run button
    ctx.fillStyle = '#44aa44'
    const btnX = screenBounds.x + screenBounds.width - 60
    const btnY = screenBounds.y + 4
    ctx.fillRect(btnX, btnY, 52, 20)
    ctx.fillStyle = '#ffffff'
    ctx.font = '12px sans-serif'
    ctx.fillText('▶ Run', btnX + 8, btnY + 15)
    
    // 🌹 — render: code
    ctx.font = '13px monospace'
    ctx.fillStyle = '#d4d4d4'
    const codeX = screenBounds.x + 8
    let codeY = screenBounds.y + headerHeight + 18
    const lineHeight = 18
    
    const lines = this.content.code.split('\n')
    for (let i = 0; i  screenBounds.y + screenBounds.height - 40) break
      
      // Line number
      ctx.fillStyle = '#666666'
      ctx.fillText(
        String(i + 1).padStart(2, ' '), 
        codeX, 
        codeY
      )
      
      // Code with basic emoji highlighting
      ctx.fillStyle = '#d4d4d4'
      ctx.fillText(lines[i], codeX + 30, codeY)
      
      codeY += lineHeight
    }
    
    // 🌹 — render: output area (if has output)
    if (this.execution.output !== null || this.execution.error !== null) {
      const outputY = screenBounds.y + screenBounds.height - 30
      ctx.fillStyle = '#252525'
      ctx.fillRect(
        screenBounds.x, 
        outputY, 
        screenBounds.width, 
        30
      )
      
      ctx.font = '12px monospace'
      if (this.execution.error) {
        ctx.fillStyle = '#ff6666'
        ctx.fillText(
          Error: ${this.execution.error}, 
          screenBounds.x + 8, 
          outputY + 20
        )
      } else {
        ctx.fillStyle = '#88ff88'
        ctx.fillText(
          Output: ${JSON.stringify(this.execution.output)}, 
          screenBounds.x + 8, 
          outputY + 20
        )
      }
    }
    
    // 🌹 — render: zip code
    if (this.zip) {
      ctx.font = '12px sans-serif'
      ctx.fillStyle = '#888888'
      ctx.fillText(
        this.zip.raw, 
        screenBounds.x + 4, 
        screenBounds.y + screenBounds.height - 8
      )
    }
  }
}


8.4 Block Manager


// src/content/BlockManager.js


class BlockManager {
  constructor() {
    // 🐂📍 — init: block storage
    this.blocks = new Map()           // id → Block
    this.blocksByZip = new Map()      // zip string → [Block]
    this.blocksByType = new Map()     // type → [Block]
    
    // 🐂📍 — init: spatial index (for fast lookup)
    this.spatialIndex = new SpatialIndex()
    
    // 🐂📍 — init: selection
    this.selectedBlocks = new Set()
    
    // 🐂📍 — init: event emitter
    this.listeners = new Map()
  }
  
  // ➕ — add: register new block
  addBlock(block) {
    // 🧮 — save to main index
    this.blocks.set(block.id, block)
    
    // 🧮 — save to type index
    if (!this.blocksByType.has(block.type)) {
      this.blocksByType.set(block.type, [])
    }
    this.blocksByType.get(block.type).push(block)
    
    // 🧮 — save to zip index
    if (block.zip) {
      const zipKey = block.zip.raw
      if (!this.blocksByZip.has(zipKey)) {
        this.blocksByZip.set(zipKey, [])
      }
      this.blocksByZip.get(zipKey).push(block)
    }
    
    // 🧮 — save to spatial index
    this.spatialIndex.insert(block)
    
    // 🚀 — emit event
    this.emit('blockAdded', block)
    
    return block
  }
  
  // ➖ — remove: unregister block
  removeBlock(blockId) {
    const block = this.blocks.get(blockId)
    if (!block) return false
    if (block.locked) return false
    
    // Remove from main index
    this.blocks.delete(blockId)
    
    // Remove from type index
    const typeBlocks = this.blocksByType.get(block.type)
    if (typeBlocks) {
      const idx = typeBlocks.indexOf(block)
      if (idx > -1) typeBlocks.splice(idx, 1)
    }
    
    // Remove from zip index
    if (block.zip) {
      const zipBlocks = this.blocksByZip.get(block.zip.raw)
      if (zipBlocks) {
        const idx = zipBlocks.indexOf(block)
        if (idx > -1) zipBlocks.splice(idx, 1)
      }
    }
    
    // Remove from spatial index
    this.spatialIndex.remove(block)
    
    // Remove from selection
    this.selectedBlocks.delete(blockId)
    
    // 🚀 — emit event
    this.emit('blockRemoved', block)
    
    return true
  }
  
  // 👀 — inspect: get block by id
  getBlock(id) {
    return this.blocks.get(id)
  }
  
  // 👀 — inspect: get blocks by zip
  getBlocksByZip(zip) {
    const zipKey = typeof zip === 'string' ? zip : zip.raw
    return this.blocksByZip.get(zipKey) || []
  }
  
  // 👀 — inspect: get blocks by type
  getBlocksByType(type) {
    return this.blocksByType.get(type) || []
  }
  
  // 👀 — inspect: get all blocks
  getAllBlocks() {
    return Array.from(this.blocks.values())
  }
  
  // 👀 — inspect: get blocks in viewport
  getBlocksInViewport(viewport) {
    return this.spatialIndex.query(viewport.getBounds())
  }
  
  // 👀 — inspect: get block at point
  getBlockAtPoint(x, y) {
    const candidates = this.spatialIndex.queryPoint(x, y)
    // Return topmost (last added) block
    return candidates.length > 0 ? candidates[candidates.length - 1] : null
  }
  
  // 📍 — place: move block
  moveBlock(blockId, x, y) {
    const block = this.blocks.get(blockId)
    if (!block) return false
    
    // Update spatial index
    this.spatialIndex.remove(block)
    const success = block.moveTo(x, y)
    if (success) {
      this.spatialIndex.insert(block)
      this.emit('blockMoved', block)
    }
    return success
  }
  
  // 📍 — place: resize block
  resizeBlock(blockId, width, height) {
    const block = this.blocks.get(blockId)
    if (!block) return false
    
    // Update spatial index
    this.spatialIndex.remove(block)
    const success = block.resize(width, height)
    if (success) {
      this.spatialIndex.insert(block)
      this.emit('blockResized', block)
    }
    return success
  }
  
  // 📍 — place: update block zip
  setBlockZip(blockId, zip) {
    const block = this.blocks.get(blockId)
    if (!block) return false
    
    // Remove from old zip index
    if (block.zip) {
      const oldZipBlocks = this.blocksByZip.get(block.zip.raw)
      if (oldZipBlocks) {
        const idx = oldZipBlocks.indexOf(block)
        if (idx > -1) oldZipBlocks.splice(idx, 1)
      }
    }
    
    // Set new zip
    block.setZip(zip)
    
    // Add to new zip index
    if (zip) {
      const zipKey = zip.raw
      if (!this.blocksByZip.has(zipKey)) {
        this.blocksByZip.set(zipKey, [])
      }
      this.blocksByZip.get(zipKey).push(block)
    }
    
    this.emit('blockZipChanged', block)
    return true
  }
  
  // 🔍 — query: find blocks matching pattern
  queryBlocks(pattern) {
    // Pattern can be:
    // - {type: 'code'}
    // - {zip: '🐂🧲🛒🟡'}
    // - {zip: '_ _ _ 🔴'} (partial match)
    // - {locked: true}
    // - Combinations
    
    let results = this.getAllBlocks()
    
    if (pattern.type) {
      results = results.filter(b => b.type === pattern.type)
    }
    
    if (pattern.zip) {
      results = results.filter(b => {
        if (!b.zip) return false
        return this.zipMatches(b.zip.raw, pattern.zip)
      })
    }
    
    if (pattern.locked !== undefined) {
      results = results.filter(b => b.locked === pattern.locked)
    }
    
    return results
  }
  
  // 🦉 — parse: check if zip matches pattern (supports wildcards)
  zipMatches(zipRaw, pattern) {
    // Pattern with _ means wildcard
    // "_ _ _ 🔴" matches any zip ending in 🔴
    const zipParts = [...zipRaw]  // Split into emoji array
    const patternParts = pattern.split(' ').filter(p => p.length > 0)
    
    if (patternParts.length !== zipParts.length) return false
    
    for (let i = 0; i  this.blocks.get(id))
      .filter(b => b !== undefined)
  }
  
  // 🚀🛒 — dispatch: serialize all blocks
  serialize() {
    return Array.from(this.blocks.values())
      .map(block => block.serialize())
  }
  
  // 🧲🪡 — capture: deserialize blocks
  deserialize(data) {
    for (const blockData of data) {
      const block = this.createBlockFromData(blockData)
      if (block) {
        this.addBlock(block)
      }
    }
  }
  
  // 🤌 — make: create block from serialized data
  createBlockFromData(data) {
    const BlockClasses = {
      text: TextBlock,
      table: TableBlock,
      form: FormBlock,
      code: CodeBlock,
      media: MediaBlock,
      tool: ToolBlock,
      composite: CompositeBlock,
      reference: ReferenceBlock
    }
    
    const BlockClass = BlockClasses[data.type]
    if (!BlockClass) {
      console.warn(Unknown block type: ${data.type})
      return null
    }
    
    // Parse zip string back to ZipCode object
    if (data.zip && typeof data.zip === 'string') {
      data.zip = ZipCode.fromString(data.zip)
    }
    
    return new BlockClass(data)
  }
  
  // 🐬 — connect: event system
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, [])
    }
    this.listeners.get(event).push(callback)
  }
  
  emit(event, data) {
    const callbacks = this.listeners.get(event) || []
    for (const callback of callbacks) {
      callback(data)
    }
  }
}


8.5 Spatial Index


// src/content/SpatialIndex.js


// Simple spatial index using a grid-based approach
// For large canvases, could upgrade to quadtree


class SpatialIndex {
  constructor(cellSize = 100) {
    this.cellSize = cellSize
    this.cells = new Map()  // "x,y" → [Block]
  }
  
  // 🔢 — get cell key for a position
  getCellKey(x, y) {
    const cellX = Math.floor(x / this.cellSize)
    const cellY = Math.floor(y / this.cellSize)
    return ${cellX},${cellY}
  }
  
  // 🔢 — get all cell keys a block occupies
  getBlockCellKeys(block) {
    const bounds = block.getBounds()
    const keys = []
    
    const startCellX = Math.floor(bounds.x / this.cellSize)
    const endCellX = Math.floor(bounds.right / this.cellSize)
    const startCellY = Math.floor(bounds.y / this.cellSize)
    const endCellY = Math.floor(bounds.bottom / this.cellSize)
    
    for (let cx = startCellX; cx  -1) {
          cell.splice(idx, 1)
        }
      }
    }
  }
  
  // 👀 — query: get blocks in bounds
  query(bounds) {
    const results = new Set()
    
    const startCellX = Math.floor(bounds.x / this.cellSize)
    const endCellX = Math.floor((bounds.x + bounds.width) / this.cellSize)
    const startCellY = Math.floor(bounds.y / this.cellSize)
    const endCellY = Math.floor((bounds.y + bounds.height) / this.cellSize)
    
    for (let cx = startCellX; cx  block.containsPoint(x, y))
  }
  
  // 🦉 — check if two bounds intersect
  boundsIntersect(a, b) {
    return !(a.x + a.width <= b.x || 
             b.x + b.width <= a.x || 
             a.y + a.height <= b.y || 
             b.y + b.height <= a.y)
  }
}


🧮 Section 9: Summary


What You Now Have


A complete specification for Blocks in Graph Parti:


1. 8 Block Types — Text, Table, Form, Code, Media, Tool, Composite, Reference
2. Base Properties — Position, size, zip, locked, connections, annotations
3. Lifecycle — Create, modify, destroy with proper state management
4. Connections — Triggers, conditions, actions linking blocks
5. Execution — How blocks run code and respond to events
6. Rendering — How blocks appear at different zoom levels and states
7. Implementation — Actual JavaScript classes ready to use


Key Insights


Blocks are the atoms of interactivity. Cells and strokes are display-only. Blocks do things.


Connections make it a program. Without connections, it's just a canvas. With connections, it's a state machine, a game, an app.


Zip codes are addresses AND selectors. You can find blocks, route to blocks, and organize blocks all through the same system.


Everything serializes. Every block type can be saved to .parti and restored exactly.


Text eraser tool in Krita - A brush that only erases text, not drawings. This would be useful for editing documents on canvas quickly. Krita can't do this natively, but Graph Parti could.
Custom Graph Parti keyboard - For mobile/touch, a custom keyboard with SCL emojis built in, predictive text for zip codes, smart suggestions based on context. Like how Samsung's GoodLock lets you customize keyboards.
Predictive coding input - Like smartphone keyboards suggest words, Graph Parti could suggest zip codes, emojis, brackets, syntax based on context.
UI changes per sheet - Each of the 7 order sheets has different tools/UI relevant to that sheet's purpose. Not a static UI, but one that adapts to the current sheet.
Color themes per sheet/district - The entire UI theme changes based on the current sheet (Tuscan, Doric, Ionic, etc.) and based on the color code (🔴🟡🟢 etc.). Visual feedback for "where you are" in the system.
Architectural rendering of context - The UI can render the current district/zip in its architectural style. Like a Nolli map (figure-ground), showing the context visually.
Each sheet themed by classical architecture - The 7 orders ARE classical architectural orders:


🐂 Tuscan Order
⛽ Doric Order
🦋 Ionic Order
🏟 Corinthian Order
🌾 Composite Order
⚖ Vitruvian Order (named after Vitruvius)
🖼 Palladian Order (named after Andrea Palladio)


 Graph Parti from "a programming tool" to "a universal workspace for any creative/technical discipline.


The scope extends far beyond code—this becomes a platform for urban planning, city mapping, construction projects, and architectural visualization. Watercolor-style renderings replace sterile 3D models. It's a tool for classical architecture education, restoration work, and real estate development. The 6 Axes themselves draw from classical principles: Firmitas (structure), Utilitas (function), Venustas (beauty), and more—each rooted in architectural theory.
Construction teams gain real-time visibility into project progress, with job site communication, daily work lists, and photos embedded directly into plans. Architecture firms collaborate across entire projects with clients, interior designers, and homeowners, documenting site visits as they go. The drafting tools themselves mirror traditional practice—parallel bars with auto-snap, scale snapping, variable line weights matching pencil grades, smart shape recognition that perfects geometry, and CAD block integration tied to geographic data.
For architecture students, particularly at schools like ACBA, this becomes a digital drafting copilot supporting collaborative trades projects and capstone work while building a portfolio across their entire education. The tool extends beyond architecture into game world design, 3D printing models, engineering, and graphic design—any creative discipline where ".parti" becomes the standard deliverable format. The user's background in classical and modern architecture explains the spatial thinking embedded throughout Graph Parti's design, which functions simultaneously as a workspace, an architecture tool, and a construction management system.


🧲        capio        capture, get, receive, contain, accept, input
🐋        duco        orchestrate, lead, conduct, produce, arrange
🤌        facio        act, make, execute, create, perform, cause
🧸        fero        channel, carry, transfer, pass, move, yield
✒️        grapho        write, record, inscribe, document, mark
🦉        logos        parse, reason, evaluate, calculate, interpret
🚀        mitto        dispatch, send, emit, launch, commit, return
🦢        plico        compress, fold, layer, nest, merge, compose
📍        pono        set, place, position, assign, establish
👀        specio        inspect, observe, query, read, examine
🥨        tendo        span, stretch, extend, reach, push
🪵        teneo        pause, hold, retain, persist, store, anchor


these can even be the buttons you click to add factor into the context tooling and also the each emoji is polysemic so it makes context emojis and contextuall tool on the sheet pages more contextual, so part of these become knowing the icon of one button has multiple tool uses on differnt layers so its also organizing the tool pallet based on the page you are on.


same ui, but the tool icon changes, knowing the shape or icon tells you the use case on tools potentially.


but also for the whole archideck idea, and the architecture program itself.


this is maximum output and orchestration.


this should explain the pieces that are tied to the zips and grouped and made into text lists with zip codes and containers, this can be zips subject + rubric context.


this should not be verbose, but constrained without losing details of connection points. this may require multiple attempts.


working through the same context